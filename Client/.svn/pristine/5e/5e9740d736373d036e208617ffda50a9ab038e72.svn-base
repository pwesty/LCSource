#include "stdh.h"

#include <Engine/Base/Timer.h>
#include <Engine/Base/Input.h>
#include <Engine/Base/Translation.h>
#include <Engine/Base/KeyNames.h>
#include <Engine/Math/Functions.h>
#include <Engine/Graphics/Viewport.h>
#include <Engine/Base/Console.h>
#include <Engine/Base/Synchronization.h>
#include <Engine/Base/Shell.h>
#include <Engine/Base/ErrorReporting.h>
#include <Engine/Templates/StaticStackArray.cpp>
//#include <Engine/Interface/UIManager.h>			// yjpark

extern HWND _hwndMain;

// input
extern INDEX inp_iKeyboardReadingMethod = 2;  // 0=getasynckey, 1=virtkeytrap, 2=scancodetrap
extern INDEX inp_bAllowMouseAcceleration = TRUE;
extern FLOAT inp_fMouseSensitivity = 1.0f;
extern INDEX inp_bMousePrecision = FALSE;
extern FLOAT inp_fMousePrecisionFactor = 4.0f;
extern FLOAT inp_fMousePrecisionThreshold = 10.0f;
extern FLOAT inp_fMousePrecisionTimeout = 0.25f;
extern FLOAT inp_bInvertMouse = FALSE;
extern INDEX inp_bFilterMouse = FALSE;
extern INDEX inp_bAllowPrescan = TRUE;

extern INDEX inp_i2ndMousePort = 0; // COM no (0=disable)
extern FLOAT inp_f2ndMouseSensitivity = 1.0f;
extern INDEX inp_b2ndMousePrecision = FALSE;
extern FLOAT inp_f2ndMousePrecisionFactor = 4.0f;
extern FLOAT inp_f2ndMousePrecisionThreshold = 10.0f;
extern FLOAT inp_f2ndMousePrecisionTimeout = 0.25f;
extern INDEX inp_bInvert2ndMouse = FALSE;
extern INDEX inp_bFilter2ndMouse = FALSE;

extern INDEX inp_iMButton4Dn = 0x20040;
extern INDEX inp_iMButton4Up = 0x20000;
extern INDEX inp_iMButton5Dn = 0x10020;
extern INDEX inp_iMButton5Up = 0x10000;
extern INDEX inp_bMsgDebugger = FALSE;
extern INDEX inp_bForceJoystickPolling = 0;
extern INDEX inp_ctJoysticksAllowed = 8;
extern INDEX inp_bAutoDisableJoysticks = 0;

// autogenerated fast conversion tables
INDEX _aiScanToKid[512];
INDEX _aiVirtToKid[256];
static char  _achKidToChar[256];
static char  _achKidToShiftChar[256];

// which keys are pressed, as recorded by message interception (by KIDs)
UBYTE _abKeysPressed[256];

int _iMouseZ = 0;

//#define	WORLD_EDITOR

#ifdef WORLD_EDITOR
typedef MSG MSGTYPE;
#else
typedef CWPSTRUCT MSGTYPE;
#endif

static void ReadDevice(CInputDevice &idDevice, BOOL bPreScane);

#define XGP_ABUTTON_DEADZONE 0x20
#define XGP_AXIS_DEADZONE 8000

// pointer to global input object
CInput *_pInput = NULL;
extern BOOL	_bWorldEditorApp;

// second mouse static variables
#define MOUSECOMBUFFERSIZE 256L
static HANDLE _h2ndMouse = NONE;
static BOOL  _bIgnoreMouse2 = TRUE;
static INDEX _i2ndMouseX, _i2ndMouseY, _i2ndMouseButtons;
static INDEX _iByteNum = 0;
static UBYTE _aubComBytes[4] = {0,0,0,0};
static INDEX _iLastPort = -1;

#if	!defined(WINDOW_SDK_70A)
/*
 * Structure used by WH_MOUSE_LL
 */
typedef struct tagMSLLHOOKSTRUCT {
    POINT   pt;
    DWORD   mouseData;
    DWORD   flags;
    DWORD   time;
    ULONG_PTR dwExtraInfo;
} MSLLHOOKSTRUCT, FAR *LPMSLLHOOKSTRUCT, *PMSLLHOOKSTRUCT;

#endif

//#define XBGP_AXIS_DEAD_ZONE 7864 // 0.24f

/*

NOTE: Three different types of key codes are used here:
	1) kid - engine internal type - defined in KeyNames.h
	2) scancode - raw PC keyboard scancodes as returned in keydown/keyup messages
	3) virtkey - virtual key codes used by windows

*/

// name that is not translated (international)
#define INTNAME(str) str, ""
// name that is translated
#define TRANAME(str) str, "ETRS" str

// basic key conversion table
static struct KeyConversion {
	INDEX kc_iKID;
	INDEX kc_iVirtKey;
	INDEX kc_iScanCode;
	char  kc_chChar;
	char  kc_chShiftChar;
	char *kc_strName;
	char *kc_strNameTrans;
} _akcKeys[] = {

	// reserved for 'no-key-pressed'
	{ KID_NONE, -1, -1, -1, -1,TRANAME("None")},
														
// numbers row              
	{ KID_1               , '1',   2, '1', '!',INTNAME("1")},
	{ KID_2               , '2',   3, '2', '@',INTNAME("2")},
	{ KID_3               , '3',   4, '3', '#',INTNAME("3")},
	{ KID_4               , '4',   5, '4', '$',INTNAME("4")},
	{ KID_5               , '5',   6, '5', '%',INTNAME("5")},
	{ KID_6               , '6',   7, '6', '^',INTNAME("6")},
	{ KID_7               , '7',   8, '7', '&',INTNAME("7")},
	{ KID_8               , '8',   9, '8', '*',INTNAME("8")},
	{ KID_9               , '9',  10, '9', '(',INTNAME("9")},
	{ KID_0               , '0',  11, '0', ')',INTNAME("0")},
	{ KID_MINUS           , 189,  12, '-', '_',INTNAME("-")},
	{ KID_EQUALS          , 187,  13, '=', '+',INTNAME("=")},
														
// 1st alpha row            
	{ KID_Q               , 'Q',  16, 'q', 'Q',INTNAME("Q")},
	{ KID_W               , 'W',  17, 'w', 'W',INTNAME("W")},
	{ KID_E               , 'E',  18, 'e', 'E',INTNAME("E")},
	{ KID_R               , 'R',  19, 'r', 'R',INTNAME("R")},
	{ KID_T               , 'T',  20, 't', 'T',INTNAME("T")},
	{ KID_Y               , 'Y',  21, 'y', 'Y',INTNAME("Y")},
	{ KID_U               , 'U',  22, 'u', 'U',INTNAME("U")},
	{ KID_I               , 'I',  23, 'i', 'I',INTNAME("I")},
	{ KID_O               , 'O',  24, 'o', 'O',INTNAME("O")},
	{ KID_P               , 'P',  25, 'p', 'P',INTNAME("P")},
	{ KID_LBRACKET        , 219,  26, '[', '{',INTNAME("[")},
	{ KID_RBRACKET        , 221,  27, ']', '}',INTNAME("]")},
	{ KID_BACKSLASH       , 220,  43, '\\','|',INTNAME("\\")},
														
// 2nd alpha row            
	{ KID_A               , 'A',  30, 'a', 'A',INTNAME("A")},
	{ KID_S               , 'S',  31, 's', 'S',INTNAME("S")},
	{ KID_D               , 'D',  32, 'd', 'D',INTNAME("D")},
	{ KID_F               , 'F',  33, 'f', 'F',INTNAME("F")},
	{ KID_G               , 'G',  34, 'g', 'G',INTNAME("G")},
	{ KID_H               , 'H',  35, 'h', 'H',INTNAME("H")},
	{ KID_J               , 'J',  36, 'j', 'J',INTNAME("J")},
	{ KID_K               , 'K',  37, 'k', 'K',INTNAME("K")},
	{ KID_L               , 'L',  38, 'l', 'L',INTNAME("L")},
	{ KID_SEMICOLON       , 186,  39, ';', ':',INTNAME(";")},
	{ KID_APOSTROPHE      , 222,  40, '\'','\"',INTNAME("'")},
// 3rd alpha row
	{ KID_Z               , 'Z',  44, 'z', 'Z',INTNAME("Z")},
	{ KID_X               , 'X',  45, 'x', 'X',INTNAME("X")},
	{ KID_C               , 'C',  46, 'c', 'C',INTNAME("C")},
	{ KID_V               , 'V',  47, 'v', 'V',INTNAME("V")},
	{ KID_B               , 'B',  48, 'b', 'B',INTNAME("B")},
	{ KID_N               , 'N',  49, 'n', 'N',INTNAME("N")},
	{ KID_M               , 'M',  50, 'm', 'M',INTNAME("M")},
	{ KID_COMMA           , 190,  51, '.', '>',INTNAME(",")},
	{ KID_PERIOD          , 188,  52, ',', '<',INTNAME(".")},
	{ KID_SLASH           , 191,  53, '/', '?',INTNAME("/")},
																			 
// row with F-keys                     
	{ KID_F1              ,  VK_F1,  59, -1, -1, INTNAME("F1")},
	{ KID_F2              ,  VK_F2,  60, -1, -1, INTNAME("F2")},
	{ KID_F3              ,  VK_F3,  61, -1, -1, INTNAME("F3")},
	{ KID_F4              ,  VK_F4,  62, -1, -1, INTNAME("F4")},
	{ KID_F5              ,  VK_F5,  63, -1, -1, INTNAME("F5")},
	{ KID_F6              ,  VK_F6,  64, -1, -1, INTNAME("F6")},
	{ KID_F7              ,  VK_F7,  65, -1, -1, INTNAME("F7")},
	{ KID_F8              ,  VK_F8,  66, -1, -1, INTNAME("F8")},
	{ KID_F9              ,  VK_F9,  67, -1, -1, INTNAME("F9")},
	{ KID_F10             , VK_F10,  68, -1, -1, INTNAME("F10")},
	{ KID_F11             , VK_F11,  87, -1, -1, INTNAME("F11")},
	{ KID_F12             , VK_F12,  88, -1, -1, INTNAME("F12")},
											 
	
// extra keys               
	{ KID_ESCAPE          , VK_ESCAPE,     1, 27, 27, TRANAME("Escape")},

	{ KID_BACKSPACE       , VK_BACK,      14,  8,  8, TRANAME("Backspace")},
	{ KID_TAB             , VK_TAB,       15,  7,  7, TRANAME("Tab")},
	{ KID_CAPSLOCK        , VK_CAPITAL,   58, -1, -1, TRANAME("Caps Lock")},
	{ KID_ENTER           , VK_RETURN,    28, 13, 13, TRANAME("Enter")},
	{ KID_SPACE           , VK_SPACE,     57, ' ',' ',TRANAME("Space")},
																						
// modifier keys                            
	{ KID_LSHIFT          , VK_LSHIFT  , 42,      -1, -1,TRANAME("Left Shift")},
	{ KID_RSHIFT          , VK_RSHIFT  , 54,      -1, -1,TRANAME("Right Shift")},
	{ KID_LCONTROL        , VK_LCONTROL, 29,      -1, -1,TRANAME("Left Control")},
	{ KID_RCONTROL        , VK_RCONTROL, 256+29,  -1, -1,TRANAME("Right Control")},
	{ KID_LALT            , VK_LMENU   , 56,      -1, -1,TRANAME("Left Alt")},
	{ KID_RALT            , VK_RMENU   , 256+56,  -1, -1,TRANAME("Right Alt")},
														
// navigation keys          
	{ KID_ARROWUP         , VK_UP,        256+72, -1, -1,TRANAME("Arrow Up")},
	{ KID_ARROWDOWN       , VK_DOWN,      256+80, -1, -1,TRANAME("Arrow Down")},
	{ KID_ARROWLEFT       , VK_LEFT,      256+75, -1, -1,TRANAME("Arrow Left")},
	{ KID_ARROWRIGHT      , VK_RIGHT,     256+77, -1, -1,TRANAME("Arrow Right")},
	{ KID_INSERT          , VK_INSERT,    256+82, -1, -1,TRANAME("Insert")},
	{ KID_DELETE          , VK_DELETE,    256+83, -1, -1,TRANAME("Delete")},
	{ KID_HOME            , VK_HOME,      256+71, -1, -1,TRANAME("Home")},
	{ KID_END             , VK_END,       256+79, -1, -1,TRANAME("End")},
	{ KID_PAGEUP          , VK_PRIOR,     256+73, -1, -1,TRANAME("Page Up")},
	{ KID_PAGEDOWN        , VK_NEXT,      256+81, -1, -1,TRANAME("Page Down")},
	{ KID_PRINTSCR        , VK_SNAPSHOT,  256+55, -1, -1,TRANAME("Print Screen")},
	{ KID_SCROLLLOCK      , VK_SCROLL,    70,     -1, -1,TRANAME("Scroll Lock")},
	{ KID_PAUSE           , VK_PAUSE,     69,     -1, -1,TRANAME("Pause")},
														
// numpad numbers           
	{ KID_NUM0            , VK_NUMPAD0, 82,       '0','0',INTNAME("Num 0")},
	{ KID_NUM1            , VK_NUMPAD1, 79,       '1','1',INTNAME("Num 1")},
	{ KID_NUM2            , VK_NUMPAD2, 80,       '2','2',INTNAME("Num 2")},
	{ KID_NUM3            , VK_NUMPAD3, 81,       '3','3',INTNAME("Num 3")},
	{ KID_NUM4            , VK_NUMPAD4, 75,       '4','4',INTNAME("Num 4")},
	{ KID_NUM5            , VK_NUMPAD5, 76,       '5','5',INTNAME("Num 5")},
	{ KID_NUM6            , VK_NUMPAD6, 77,       '6','6',INTNAME("Num 6")},
	{ KID_NUM7            , VK_NUMPAD7, 71,       '7','7',INTNAME("Num 7")},
	{ KID_NUM8            , VK_NUMPAD8, 72,       '8','8',INTNAME("Num 8")},
	{ KID_NUM9            , VK_NUMPAD9, 73,       '9','9',INTNAME("Num 9")},
	{ KID_NUMDECIMAL      , VK_DECIMAL, 83,       '.','.',INTNAME("Num .")},
														
// numpad gray keys         
	{ KID_NUMLOCK         , VK_NUMLOCK,   256+69, -1, -1, INTNAME("Num Lock")},
	{ KID_NUMSLASH        , VK_DIVIDE,    256+53, '/','/',INTNAME("Num /")},
	{ KID_NUMMULTIPLY     , VK_MULTIPLY,  55,     '*','*',INTNAME("Num *")},
	{ KID_NUMMINUS        , VK_SUBTRACT,  74,     '-','-',INTNAME("Num -")},
	{ KID_NUMPLUS         , VK_ADD,       78,     '+','+',INTNAME("Num +")},
	{ KID_NUMENTER        , VK_SEPARATOR, 256+28, -1, -1, TRANAME("Num Enter")},
// mouse buttons
	{ KID_MOUSE1          , VK_LBUTTON, -1, -1, -1,       TRANAME("Mouse Button 1")},
	{ KID_MOUSE2          , VK_RBUTTON, -1, -1, -1,       TRANAME("Mouse Button 2")},
	{ KID_MOUSE3          , VK_MBUTTON, -1, -1, -1,       TRANAME("Mouse Button 3")},
	{ KID_MOUSE4          , -1, -1, -1, -1, TRANAME("Mouse Button 4")},
	{ KID_MOUSE5          , -1, -1, -1, -1, TRANAME("Mouse Button 5")},
	{ KID_MOUSEWHEELUP    , -1, -1, -1, -1, TRANAME("Mouse Wheel Up")},
	{ KID_MOUSEWHEELDOWN  , -1, -1, -1, -1, TRANAME("Mouse Wheel Down")},

// 2nd mouse buttons
	{ KID_2MOUSE1         , -1, -1, -1, -1, TRANAME("2nd Mouse Button 1")},
	{ KID_2MOUSE2         , -1, -1, -1, -1, TRANAME("2nd Mouse Button 2")},
	{ KID_2MOUSE3         , -1, -1, -1, -1, TRANAME("2nd Mouse Button 3")},
};

// make fast conversion tables from the general table
static void MakeConversionTables(void)
{
	// clear conversion tables
	memset(_aiScanToKid, -1, sizeof(_aiScanToKid));
	memset(_aiVirtToKid, -1, sizeof(_aiVirtToKid));
	memset(_achKidToChar, -1, sizeof(_achKidToChar));
	memset(_achKidToShiftChar, -1, sizeof(_achKidToShiftChar));

	// for each Key
	for (INDEX iKey=0; iKey<ARRAYCOUNT(_akcKeys); iKey++) {
		struct KeyConversion &kc = _akcKeys[iKey];

		// get codes
		INDEX iKID  = kc.kc_iKID;
		INDEX iScan = kc.kc_iScanCode;
		INDEX iVirt = kc.kc_iVirtKey;
		char  chChar = kc.kc_chChar;
		char  chShiftChar = kc.kc_chShiftChar;

		// update the tables
		if (iScan>=0) {
			_aiScanToKid[iScan] = iKID;
		}
		if (iVirt>=0) {
			_aiVirtToKid[iVirt] = iKID;
		}
		if(chChar>=0) {
			_achKidToChar[iKID] = chChar;
		}
		if(chShiftChar>=0) {
			_achKidToShiftChar[iKID] = chShiftChar;
		}
	}
}

// variables for message interception
static HHOOK _hGetMsgHook = NULL;
static HHOOK _hSendMsgHook = NULL;
static HHOOK _hMouseHook = NULL;
static BOOL _bWheelUp = FALSE;
static BOOL _bWheelDn = FALSE;

CTCriticalSection csInput;

// set a key according to a keydown/keyup message
//static void SetKeyFromMsg(MSG *pMsg, BOOL bDown)
static void SetKeyFromMsg(MSGTYPE* pMsg, BOOL bDown)
{
	INDEX iKID = -1;
	// if capturing scan codes
	if (inp_iKeyboardReadingMethod==2) {
		// get scan code
		INDEX iScan = (pMsg->lParam>>16)&0x1FF; // (we use the extended bit too!)
		// convert scan code to kid
		iKID = _aiScanToKid[iScan];
	// if capturing virtual key codes
	} else if (inp_iKeyboardReadingMethod==1) {
		// get virtualkey
		INDEX iVirt = (pMsg->wParam)&0xFF;

		if (iVirt == VK_SHIFT) {
			iVirt = VK_LSHIFT;
		}
		if (iVirt == VK_CONTROL) {
			iVirt = VK_LCONTROL;
		}
		if (iVirt == VK_MENU) {
			iVirt = VK_LMENU;
		}
		// convert virtualkey to kid
		iKID = _aiVirtToKid[iVirt];
	// if not capturing
	} else {
		// do nothing
		return;
	}
	if (iKID>=0 && iKID<ARRAYCOUNT(_abKeysPressed)) {
		_abKeysPressed[iKID] = bDown;
	}
}

//static void CheckMessage(MSG *pMsg)
static void CheckMouseMsg(MSLLHOOKSTRUCT *pm, WPARAM wp)
{
#ifndef WM_MOUSEWHEEL
	#define WM_MOUSEWHEEL 0x020A
#endif

	// Get current mouse position
	if( wp >= WM_MOUSEFIRST && wp <= WM_MOUSELAST || wp == WM_MOUSEWHEEL)
	{
		RECT rectClient;
		POINT pt = pm->pt;
		GetClientRect(_pInput->m_vphWnd, &rectClient);
		ScreenToClient(_pInput->m_vphWnd, &pt);
		
		if (!PtInRect(&rectClient, pt))
		{
			return;
		}

		//OffsetRect(&rectClient, pt.x, pt.y);

		if (_bWorldEditorApp) {
//			_pInput->inp_ptMousePos.x = LOWORD(pMsg->lParam);
//			_pInput->inp_ptMousePos.y = HIWORD(pMsg->lParam);
			//_pInput->inp_ptMousePos.x = pm->pt.x;
			//_pInput->inp_ptMousePos.y = pm->pt.y;
			_pInput->inp_ptMousePos.x = pt.x;
			_pInput->inp_ptMousePos.y = pt.y;
		}
	}

	if ( wp == WM_LBUTTONUP) {
		_abKeysPressed[KID_MOUSE1] = FALSE;
	} else if ( wp == WM_LBUTTONDOWN || wp == WM_LBUTTONDBLCLK) {
		_abKeysPressed[KID_MOUSE1] = TRUE;
	} else if ( wp == WM_RBUTTONUP) {
		_abKeysPressed[KID_MOUSE2] = FALSE;
	} else if ( wp == WM_RBUTTONDOWN || wp == WM_RBUTTONDBLCLK) {
		_abKeysPressed[KID_MOUSE2] = TRUE;
	} else if ( wp == WM_MBUTTONUP) {
		_abKeysPressed[KID_MOUSE3] = FALSE;
	} else if ( wp == WM_MBUTTONDOWN || wp == WM_MBUTTONDBLCLK) {
		_abKeysPressed[KID_MOUSE3] = TRUE;
	} else if ( wp == WM_MOUSEWHEEL) {
		INDEX iWheelValue = SWORD(HIWORD(pm->mouseData));
		_iMouseZ += iWheelValue;
		_pInput->m_WheelPos = iWheelValue;
	} else if ( wp == inp_iMButton4Dn) {
		_abKeysPressed[KID_MOUSE4] = TRUE;
	} else if ( wp == inp_iMButton4Up) {
		_abKeysPressed[KID_MOUSE4] = FALSE;

	} else if ( wp == inp_iMButton5Dn) {
		_abKeysPressed[KID_MOUSE5] = TRUE;
	} else if ( wp == inp_iMButton5Up) {
		_abKeysPressed[KID_MOUSE5] = FALSE;
	} else if (inp_bMsgDebugger && wp >= 0x10000) {
		CPrintF("%08x(%d)\n", wp, wp);
	}
}

static void CheckKeyMsg(MSGTYPE *pMsg)
{
	if (pMsg->message==WM_KEYUP || pMsg->message==WM_SYSKEYUP) {
		SetKeyFromMsg(pMsg, FALSE);
	} else if (pMsg->message==WM_KEYDOWN || pMsg->message==WM_SYSKEYDOWN) {
		SetKeyFromMsg(pMsg, TRUE);
	}
}

// procedure called when message is retreived
LRESULT CALLBACK GetMsgProc(
	int nCode,      // hook code
	WPARAM wParam,  // message identifier
	LPARAM lParam)  // mouse coordinates
{
//	MSG *pMsg = (MSG*)lParam;
	MSGTYPE *pMsg = (MSGTYPE*)lParam;

	//CheckMessage(pMsg);
	CheckKeyMsg(pMsg);

	LRESULT retValue = 0;
	retValue = CallNextHookEx( _hGetMsgHook, nCode, wParam, lParam );

	return retValue;
}


// procedure called when message is sent
LRESULT CALLBACK SendMsgProc(
	int nCode,      // hook code
	WPARAM wParam,  // message identifier
	LPARAM lParam)  // mouse coordinates
{
//	MSG *pMsg = (MSG*)lParam;
	MSGTYPE *pMsg = (MSGTYPE*)lParam;

	CheckKeyMsg(pMsg);
	//CheckMessage(pMsg);

	LRESULT retValue = 0;
	retValue = CallNextHookEx( _hSendMsgHook, nCode, wParam, lParam );
	
	return retValue;
}

LRESULT CALLBACK LowLevelMouseProc(
	int nCode,
	WPARAM wParam,
	LPARAM lParam)
{
	MSLLHOOKSTRUCT *pm = (MSLLHOOKSTRUCT*)lParam;

	CheckMouseMsg(pm, wParam);

	LRESULT retValue = 0;
	retValue = CallNextHookEx( _hSendMsgHook, nCode, wParam, lParam);

	if (wParam == PM_NOREMOVE) {
		return retValue;
	}

	return retValue;
}

// --------- 2ND MOUSE HANDLING

static void Poll2ndMouse(void)
{
	// reset (mouse reading is relative)
	_i2ndMouseX = 0;
	_i2ndMouseY = 0;
	if( _h2ndMouse==NONE) return;

	// check
	COMSTAT csComStat;
	DWORD dwErrorFlags;
	ClearCommError( _h2ndMouse, &dwErrorFlags, &csComStat);
	DWORD dwLength = Min( MOUSECOMBUFFERSIZE, (INDEX)csComStat.cbInQue);
	if( dwLength<=0) return;

	// readout
	UBYTE aubMouseBuffer[MOUSECOMBUFFERSIZE];
	INDEX iRetries = 999;
	while( iRetries>0 && !ReadFile( _h2ndMouse, aubMouseBuffer, dwLength, &dwLength, NULL)) iRetries--;
	if( iRetries<=0) return; // what, didn't make it?

	// parse the mouse packets
	for( INDEX i=0; i<dwLength; i++)
	{
		// prepare    
		if( aubMouseBuffer[i] & 64) _iByteNum  = 0;
		if( _iByteNum<4) _aubComBytes[_iByteNum] = aubMouseBuffer[i];
		_iByteNum++;

		// buttons ?
		if( _iByteNum==1) {
			_i2ndMouseButtons &= ~3;
			_i2ndMouseButtons |= (_aubComBytes[0] & (32+16)) >>4;
		}
		// axes ?
		else if( _iByteNum==3) {
			char iDX = ((_aubComBytes[0] &  3) <<6) + _aubComBytes[1];
			char iDY = ((_aubComBytes[0] & 12) <<4) + _aubComBytes[2];
			_i2ndMouseX += iDX;
			_i2ndMouseY += iDY;
		}
		// 3rd button?
		else if( _iByteNum==4) {
			_i2ndMouseButtons &= ~4;
			if( aubMouseBuffer[i]&32) _i2ndMouseButtons |= 4;
		}
	}

	// ignore pooling?
	if( _bIgnoreMouse2) {
		if( _i2ndMouseX!=0 || _i2ndMouseY!=0) _bIgnoreMouse2 = FALSE;
		_i2ndMouseX = 0;
		_i2ndMouseY = 0;
		_i2ndMouseButtons = 0;
		return;
	}
}


static void Startup2ndMouse(INDEX iPort)
{
	// skip if disabled
	ASSERT( iPort>=0 && iPort<=4);
	if( iPort==0) return; 
	// determine port string
	CTString str2ndMousePort( 0, "COM%d", iPort);
		
	// create COM handle if needed
	if( _h2ndMouse==NONE) {
		_h2ndMouse = CreateFile( str2ndMousePort, GENERIC_READ|GENERIC_WRITE, 0, NULL,           
														 OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
		if( _h2ndMouse==INVALID_HANDLE_VALUE) {
			// failed! :(
			INDEX iError = GetLastError();
/*
			if( iError==5) CPrintF( "Cannot open %s (access denied).\n"
															"The port is probably already used by another device (mouse, modem...)\n",
															str2ndMousePort);
			else CPrintF( "Cannot open %s (error %d).\n", str2ndMousePort, iError);
			*/
			_h2ndMouse = NONE;
			return;
		}
	}
	// setup and purge buffers
	SetupComm( _h2ndMouse, MOUSECOMBUFFERSIZE, MOUSECOMBUFFERSIZE);
	PurgeComm( _h2ndMouse, PURGE_TXABORT | PURGE_RXABORT | PURGE_TXCLEAR | PURGE_RXCLEAR);

	// setup port to 1200 7N1
	DCB dcb;
	dcb.DCBlength = sizeof(DCB);
	GetCommState( _h2ndMouse, &dcb);
	dcb.BaudRate = CBR_1200;
	dcb.ByteSize = 7;
	dcb.Parity   = NOPARITY;
	dcb.StopBits = ONESTOPBIT;
	dcb.fDtrControl = DTR_CONTROL_ENABLE;
	dcb.fRtsControl = RTS_CONTROL_ENABLE;
	dcb.fBinary = TRUE;
	dcb.fParity = TRUE;
	SetCommState( _h2ndMouse, &dcb);

	// reset
	_iByteNum = 0;
	_aubComBytes[0] = _aubComBytes[1] = _aubComBytes[2] = _aubComBytes[3] = 0;
	_bIgnoreMouse2 = TRUE; // ignore mouse polling until 1 after non-0 readout 
	_iLastPort = iPort;
	//CPrintF( "STARTUP M2!\n");
}


static void Shutdown2ndMouse(void)
{
	// skip if already disabled
	if( _h2ndMouse==NONE) return;

	// disable!
	SetCommMask( _h2ndMouse, 0);
	EscapeCommFunction( _h2ndMouse, CLRDTR);
	EscapeCommFunction( _h2ndMouse, CLRRTS);
	PurgeComm( _h2ndMouse, PURGE_TXABORT | PURGE_RXABORT | PURGE_TXCLEAR | PURGE_RXCLEAR);
	// close port if changed
	if( _iLastPort != inp_i2ndMousePort) {
		CloseHandle( _h2ndMouse);
		_h2ndMouse = NONE;
	} // over and out
	_bIgnoreMouse2 = TRUE;
}

 


// deafult constructor
CInput::CInput(void)
{
	inp_csInput.cs_iIndex = -1;

	// disable control scaning
	inp_bInputEnabled = FALSE;
	inp_bPollJoysticks = FALSE;
	inp_bLastPrescan = FALSE;
	inp_bFreeMode = FALSE;

	inp_fSpeedMultiplier = 1.0f;

	// Allocate memory for devices
	inp_aInputDevices.New(MAX_DEVICES);
	// for each device
	for(INDEX iid=0;iid<MAX_DEVICES;iid++) {
		// set device index
		inp_aInputDevices[iid].id_iDeviceIndex = iid;
		// Clear control values
		inp_aInputDevices[iid].ClearControlsValue();
	}
	
	MakeConversionTables();

//0105
	m_bLMouse = FALSE;
	nViewDistance = 0.0f;
	m_bForward = FALSE;
	m_bWheelDown = FALSE;
	m_bRButtonDown = FALSE;
	m_bTcpIp = FALSE;//TRUE;////이건 TCP와 상관없이 마우스 회전에 관해서. 수정루틴이 TRUE
	m_WheelPos = 0;
	m_bLControlKey = FALSE;
	m_bPressedLControlKey = FALSE;
	m_bTabKey = FALSE;
	m_bPressedTabKey = FALSE;
	m_bPKey = FALSE;
	m_bPressedPKey = FALSE;
	m_bRKey = FALSE;
	m_bPressedRKey = FALSE;
	m_bKKey = FALSE;
	m_bPressedKKey = FALSE;
	m_bIKey = FALSE;
	m_bPressedIKey = FALSE;
	m_bLKey = FALSE;
	m_bPressedLKey = FALSE;
	m_bJKey = FALSE;
	m_bPressedJKey = FALSE;
	m_b1Key = FALSE;
	m_bPressed1Key = FALSE;
	m_b2Key = FALSE;
	m_bPressed2Key = FALSE;
	m_b3Key = FALSE;
	m_bPressed3Key = FALSE;
	m_b4Key = FALSE;
	m_bPressed4Key = FALSE;
	m_b5Key = FALSE;
	m_bPressed5Key = FALSE;
	m_b6Key = FALSE;
	m_bPressed6Key = FALSE;
	m_b9Key = FALSE;
	m_bPressed9Key = FALSE;
	m_b0Key = FALSE;
	m_bPressed0Key = FALSE;
	m_bVKey = FALSE;
	m_bPressedVKey = FALSE;
	m_bQKey = FALSE;
	m_bPressedQKey = FALSE;
	m_bTKey = FALSE;
	m_bPressedTKey = FALSE;
	m_bOKey = FALSE;
	m_bPressedOKey = FALSE;
	m_bUKey = FALSE;
	m_bPressedUKey = FALSE;
	m_bMKey = FALSE;
	m_bPressedMKey = FALSE;

	m_bWheel = FALSE;
	m_bPressedWheel = FALSE;
	m_bF2Key = FALSE;
	m_bPressedF2Key = FALSE;
	m_bF3Key = FALSE;
	m_bPressedF3Key = FALSE;
//..
}


// destructor
CInput::~CInput()
{
	if( _h2ndMouse!=NONE) CloseHandle( _h2ndMouse);
	_h2ndMouse = NONE;
}

BOOL CInput::SendIMEKeyInput(MSG* pMsg)
{
	switch(pMsg->wParam)
	{
	case VK_OEM_3: //'~' for US
		{
			pMsg->wParam = '~';
		}
		return TRUE;
	}

	for (INDEX iKey=0; iKey<ARRAYCOUNT(_akcKeys); iKey++)
	{
		struct KeyConversion &kc = _akcKeys[iKey];
		
		if (pMsg->wParam == kc.kc_iVirtKey)
		{
			if (_abKeysPressed[KID_LSHIFT] || _abKeysPressed[KID_RSHIFT])	{
				pMsg->wParam = kc.kc_chShiftChar;
			} else {
				pMsg->wParam = kc.kc_chChar;
			}

			return TRUE;
		}
	}

	return FALSE;
}

void CInput::SetJoyPolling(BOOL bPoll)
{
	inp_bPollJoysticks = bPoll;
}

/*
 * Initializes all available devices and enumerates available controls
 */

void CInput::Initialize( void )
{
	_pShell->DeclareSymbol("persistent user INDEX inp_iKeyboardReadingMethod;",   &inp_iKeyboardReadingMethod);
	_pShell->DeclareSymbol("persistent user INDEX inp_bAllowMouseAcceleration;",  &inp_bAllowMouseAcceleration);
	_pShell->DeclareSymbol("persistent user FLOAT inp_fMouseSensitivity;",        &inp_fMouseSensitivity);
	_pShell->DeclareSymbol("persistent user INDEX inp_bMousePrecision;",          &inp_bMousePrecision);
	_pShell->DeclareSymbol("persistent user FLOAT inp_fMousePrecisionFactor;",    &inp_fMousePrecisionFactor);
	_pShell->DeclareSymbol("persistent user FLOAT inp_fMousePrecisionThreshold;", &inp_fMousePrecisionThreshold);
	_pShell->DeclareSymbol("persistent user FLOAT inp_fMousePrecisionTimeout;",   &inp_fMousePrecisionTimeout);
	_pShell->DeclareSymbol("persistent user INDEX inp_bInvertMouse;",    &inp_bInvertMouse);
	_pShell->DeclareSymbol("persistent user INDEX inp_bFilterMouse;",    &inp_bFilterMouse);
	_pShell->DeclareSymbol("persistent user INDEX inp_bAllowPrescan;",   &inp_bAllowPrescan);

	_pShell->DeclareSymbol("persistent user INDEX inp_i2ndMousePort;",   &inp_i2ndMousePort);
	_pShell->DeclareSymbol("persistent user INDEX inp_bInvert2ndMouse;", &inp_bInvert2ndMouse);
	_pShell->DeclareSymbol("persistent user INDEX inp_bFilter2ndMouse;", &inp_bFilter2ndMouse);
	_pShell->DeclareSymbol("persistent user FLOAT inp_f2ndMouseSensitivity;",        &inp_f2ndMouseSensitivity);
	_pShell->DeclareSymbol("persistent user INDEX inp_b2ndMousePrecision;",          &inp_b2ndMousePrecision);
	_pShell->DeclareSymbol("persistent user FLOAT inp_f2ndMousePrecisionFactor;",    &inp_f2ndMousePrecisionFactor);
	_pShell->DeclareSymbol("persistent user FLOAT inp_f2ndMousePrecisionThreshold;", &inp_f2ndMousePrecisionThreshold);
	_pShell->DeclareSymbol("persistent user FLOAT inp_f2ndMousePrecisionTimeout;",   &inp_f2ndMousePrecisionTimeout);
	
	_pShell->DeclareSymbol("persistent user INDEX inp_bMsgDebugger;",    &inp_bMsgDebugger);
	_pShell->DeclareSymbol("persistent user INDEX inp_iMButton4Up;", &inp_iMButton4Up);
	_pShell->DeclareSymbol("persistent user INDEX inp_iMButton4Dn;", &inp_iMButton4Dn);
	_pShell->DeclareSymbol("persistent user INDEX inp_iMButton5Up;", &inp_iMButton5Up);
	_pShell->DeclareSymbol("persistent user INDEX inp_iMButton5Dn;", &inp_iMButton5Dn);
	_pShell->DeclareSymbol("persistent user INDEX inp_ctJoysticksAllowed;",    &inp_ctJoysticksAllowed);
	_pShell->DeclareSymbol("persistent user INDEX inp_bForceJoystickPolling;", &inp_bForceJoystickPolling);
	_pShell->DeclareSymbol("persistent user INDEX inp_bAutoDisableJoysticks;", &inp_bAutoDisableJoysticks);
	
	CPrintF(TRANS("Detecting input devices...\n"));

	AddDevice(DT_NONE,DEVICE_NONE);
	// add default input devices
	AddDevice(DT_KEYBOARD,KEYBOARD_DEVICE);
	AddDevice(DT_MOUSE,MOUSE_DEVICE);
	AddDevice(DT_SECOND_MOUSE,SECOND_MOUSE_DEVICE);
	// for each allowed joystick
	for (INDEX iJoy=0;iJoy<MAX_JOYSTICKS;iJoy++) {
		// try to add joystick device
		AddDevice(DT_JOYSTICK,FIRST_JOYSTICK_DEVICE+iJoy);
	}
	
	// Set control names in all devices
	SetControlNames();
	
	_h2ndMouse = NONE;
	CPrintF("\n");
}


/*
 * Enable direct input
 */

void CInput::EnableInput(CViewPort *pvp)
{
	EnableInput(pvp->vp_hWnd);
}

void CInput::EnableInput(HWND hwnd)
{
	// skip if already enabled
	if( inp_bInputEnabled) return;

	m_vphWnd = hwnd;

	// get window rectangle
	RECT rectClient;
	GetClientRect(hwnd, &rectClient);
	POINT pt;
	pt.x=0;
	pt.y=0;
	ClientToScreen(hwnd, &pt);
	OffsetRect(&rectClient, pt.x, pt.y);
	m_rectClient = rectClient;

	// remember mouse pos
	GetCursorPos( &inp_ptOldMousePos);

	extern BOOL _bInTestGame;
	if( !_bInTestGame )
	{
		// set mouse clip region
		ClipCursor(&rectClient);
	}

	// determine screen center position
	inp_slScreenCenterX = (rectClient.left + rectClient.right) / 2;
	inp_slScreenCenterY = (rectClient.top + rectClient.bottom) / 2;

	// clear mouse from screen
	// 40906-seo
	//while (ShowCursor(TRUE) >= 0);
	// save system mouse settings
	SystemParametersInfo(SPI_GETMOUSE, 0, &inp_mscMouseSettings, 0);
	// set new mouse speed
	if (!inp_bAllowMouseAcceleration) {
		MouseSpeedControl mscNewSetting = { 0, 0, 0};
		SystemParametersInfo(SPI_SETMOUSE, 0, &mscNewSetting, 0);
	}
	// set cursor position to screen center
	SetCursorPos(inp_slScreenCenterX, inp_slScreenCenterY);

	_hGetMsgHook  = SetWindowsHookEx(WH_GETMESSAGE, &GetMsgProc, NULL, GetCurrentThreadId());
	_hSendMsgHook = SetWindowsHookEx(WH_CALLWNDPROC, &SendMsgProc, NULL, GetCurrentThreadId());
#ifndef WH_MOUSE_LL
#define WH_MOUSE_LL        14
#endif
	//_hMouseHook = SetWindowsHookEx(WH_MOUSE_LL, &LowLevelMouseProc, NULL, GetCurrentThreadId());
	HINSTANCE hInstance = GetModuleHandle(NULL);
	_hMouseHook = SetWindowsHookEx(WH_MOUSE_LL, &LowLevelMouseProc, hInstance, 0);

	// if required, try to enable 2nd mouse
	Shutdown2ndMouse(); 
	inp_i2ndMousePort = Clamp( inp_i2ndMousePort, 0L, 4L);
	Startup2ndMouse(inp_i2ndMousePort);

	// clear button's buffer
	memset( _abKeysPressed, 0, sizeof( _abKeysPressed));

	// This can be enabled to pre-read the state of currently pressed keys
	// for snooping methods, since they only detect transitions.
	// That has effect of detecting key presses for keys that were held down before
	// enabling.
	// the entire thing is disabled because it caused last menu key to re-apply in game.
#if 0
	// for each Key
	{for (INDEX iKey=0; iKey<ARRAYCOUNT(_akcKeys); iKey++) {
		struct KeyConversion &kc = _akcKeys[iKey];
		// get codes
		INDEX iKID  = kc.kc_iKID;
		INDEX iScan = kc.kc_iScanCode;
		INDEX iVirt = kc.kc_iVirtKey;

		// if there is a valid virtkey
		if (iVirt>=0) {
			// transcribe if modifier
			if (iVirt == VK_LSHIFT) {
				iVirt = VK_SHIFT;
			}
			if (iVirt == VK_LCONTROL) {
				iVirt = VK_CONTROL;
			}
			if (iVirt == VK_LMENU) {
				iVirt = VK_MENU;
			}
			// is state is pressed
			if (GetAsyncKeyState(iVirt)&0x8000) {
				// mark it as pressed
				_abKeysPressed[iKID] = 0xFF;
			}
		}
	}}
#endif
	
	// remember current status
	inp_bInputEnabled = TRUE;
	inp_bPollJoysticks = FALSE;
}

/*
 * Disable direct input
 */
void CInput::DisableInput( void)
{
	// skip if already disabled
	if( !inp_bInputEnabled) return;
	
	UnhookWindowsHookEx(_hGetMsgHook);
	UnhookWindowsHookEx(_hSendMsgHook);
	UnhookWindowsHookEx(_hMouseHook);

	// set mouse clip region to entire screen
	ClipCursor(NULL);
	// restore mouse pos
	SetCursorPos( inp_ptOldMousePos.x, inp_ptOldMousePos.y);

	// show mouse on screen
	// 40906-seo
	//while (ShowCursor(TRUE) < 0);
	// set system mouse settings
	SystemParametersInfo(SPI_SETMOUSE, 0, &inp_mscMouseSettings, 0);

	// eventually disable 2nd mouse
	Shutdown2ndMouse();

	// remember current status
	inp_bInputEnabled = FALSE;
	inp_bPollJoysticks = FALSE;
}

/*
 * Scan states of all available input sources
 */

void CInput::GetInput(BOOL bPreScan)
{
	CTSingleLock slInput(&inp_csInput, TRUE);  // don't allow multiple threads here

	if (!inp_bInputEnabled) {
		return;
	}

	if (bPreScan && !inp_bAllowPrescan) {
		return;
	}

	// for each input device
	for(INDEX iid=0;iid<GetInputDevicesCount();iid++) {
		CInputDevice &idDevice = inp_aInputDevices[iid];
		ReadDevice(idDevice,bPreScan);
	}
	inp_bLastPrescan = bPreScan;
}

// Clear all input states (keys become not pressed, axes are reset to zero)
void CInput::ClearInput( void)
{
	ASSERT(FALSE);
}

BOOL CInput::AddDevice(DeviceType dtDeviceType, INDEX iDeviceIndex)
{
	CInputDevice &idDevice = inp_aInputDevices[iDeviceIndex];
	BOOL bSucceeded = idDevice.InitDevice(dtDeviceType);
	// if failed
	if(bSucceeded) {
		// disable device
		idDevice.EnableDevice();
	}
	return bSucceeded;
}

BOOL CInput::RemoveDevice(CInputDevice &idDevice)
{
	ASSERT(FALSE);
	return FALSE;
}

// Get reference to device by device index
CInputDevice *CInput::GetInputDevice(INDEX iDevice)
{
	if(iDevice<GetInputDevicesCount()) {
		return &inp_aInputDevices[iDevice];
	} else {
		return NULL;
	}
}

// Get reference to device by device name
CInputDevice *CInput::GetInputDevice(const CTString &strDevice)
{
	// for each input device
	INDEX ctid=GetInputDevicesCount();
	for(INDEX iid=0;iid<ctid;iid++) {
		CInputDevice *pidDevice = GetInputDevice(iid);
		// if device exists
		if(pidDevice!=NULL) {
			// compare name of device with searched string
			if(pidDevice->id_strDeviceName == strDevice) {
				return pidDevice;
			}
		}
	}
	return NULL;
}

// Get control global id from device name and control name
ULONG CInput::GetControlGIDFromString(const CTString &strDevice, const CTString &strControl)
{
	CInputDevice *pidDevice = GetInputDevice(strDevice);
	// if device exists
	if(pidDevice!=NULL) {
		INDEX iControl = pidDevice->GetControl(strControl);
		return GetControlGID(pidDevice->id_iDeviceIndex,iControl);
	}
	return CONTROL_NONE;
}

// Get value of control
FLOAT CInput::GetControlValue(ULONG ulControlGID)
{
	const INDEX iDevice  = GetInputDeviceID(ulControlGID);
	const INDEX iControl = GetControlLID(ulControlGID);
	CInputDevice &idDevice  = inp_aInputDevices[iDevice];
	InputControl &icControl = idDevice.id_aicControls[iControl];
	return icControl.ic_fValue;
}

//0105
void CInput::SetControlValue(ULONG ulControlGID)
{
	const INDEX iDevice  = GetInputDeviceID(ulControlGID);
	const INDEX iControl = GetControlLID(ulControlGID);
	CInputDevice &idDevice  = inp_aInputDevices[iDevice];
	idDevice.id_aicControls[iControl].ic_fValue = 1.0f;
//  InputControl &icControl = idDevice.id_aicControls[iControl];
//  return icControl.ic_fValue;
}
//..

// Get control name
CTString CInput::GetControlName(ULONG ulControlGID)
{
	const INDEX iDevice  = GetInputDeviceID(ulControlGID);
	const INDEX iControl = GetControlLID(ulControlGID);
	CInputDevice &idDevice  = inp_aInputDevices[iDevice];
	InputControl &icControl = idDevice.id_aicControls[iControl];
	return icControl.ic_strControlName;
}

// Get translated control name
CTString CInput::GetControlTransName(ULONG ulControlGID)
{
	const INDEX iDevice  = GetInputDeviceID(ulControlGID);
	const INDEX iControl = GetControlLID(ulControlGID);
	CInputDevice &idDevice  = inp_aInputDevices[iDevice];
	InputControl &icControl = idDevice.id_aicControls[iControl];
	return icControl.ic_strControlNameTrans;
}

// Get translated control name
CTString CInput::GetInputDeviceName(INDEX iDevice)
{
	CInputDevice &idDevice = inp_aInputDevices[iDevice];
	return idDevice.id_strDeviceName;
}

CTString CInput::GetInputDeviceShortName(INDEX iDevice)
{
	CInputDevice &idDevice = inp_aInputDevices[iDevice];
	return idDevice.id_strDeviceShortName;
}

//0601 kwon 추가.
BOOL CInput::IsLControlKeyPressing()
{
	if(_abKeysPressed[KID_LCONTROL])
	{
		return TRUE;
	}
	else{
		return FALSE;
	}
}

//0615 kwon
BOOL CInput::IsRMouseButtonPressed()
{
	if(_abKeysPressed[KID_MOUSE2])
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}
	
}

BOOL CInput::IsLMouseButtonPressed()
{
	if(_abKeysPressed[KID_MOUSE1])
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}
	
}
/*
BOOL CInput::IsHomePressed()
{
	if(_abKeysPressed[KID_HOME])
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}
	
}
*/
CInputDevice::CInputDevice()
{
	id_dtDeviceType   = DT_NONE;
	id_bDeviceEnabled = FALSE;
	id_iDeviceIndex   = -1;
}

CInputDevice::~CInputDevice()
{
}

	// Does joystick has pov
BOOL CInputDevice::HasJoystickPOV()
{
	// if this isn't joystick
	if(id_dtDeviceType!=DT_JOYSTICK) {
		ASSERTALWAYS("Device isn't joystick");
		return FALSE;
	}

	BOOL bHasPOV = id_aicControls[FIRST_POV_CONTROL+0].ic_bExisting && id_aicControls[FIRST_POV_CONTROL+1].ic_bExisting &&
					id_aicControls[FIRST_POV_CONTROL+2].ic_bExisting && id_aicControls[FIRST_POV_CONTROL+3].ic_bExisting;
	return bHasPOV;
}

// Get count of controls this device has
INDEX CInputDevice::GetControlsCount(void)
{
	return id_aicControls.Count();
}

// Get control by control name
INDEX CInputDevice::GetControl(const CTString &strControl)
{
	// for each control
	INDEX ctct = GetControlsCount();
	for(INDEX ict=0;ict<ctct;ict++) {
		InputControl &icControl = id_aicControls[ict];
		// if control name match given string
		if(icControl.ic_strControlName == strControl) {
			// return this control index
			return ict;
		}
	}
	return 0;
}

// Get value from given control
FLOAT CInputDevice::GetControlValue(INDEX iControl)
{
	InputControl &icControl = id_aicControls[iControl];
	// if control is enabled 
	if(icControl.ic_bExisting) {
		// return its value
		return icControl.ic_fValue;
	} else {
		// return 0
		return 0;
	}
}

// Set all control values to 0
void CInputDevice::ClearControlsValue(void)
{
	// for each control
	INDEX ctct = GetControlsCount();
	for(INDEX ict=0;ict<ctct;ict++) {
		// set its value to 0
		InputControl &icControl = id_aicControls[ict];
		icControl.ic_fValue = 0;
	}
}

// Enable input device
void CInputDevice::EnableDevice(void)
{
	// if device already enabled 
	if(id_bDeviceEnabled) {
		// do nothing
		return;
	}


	ClearControlsValue();
	id_bDeviceEnabled = TRUE;
}

// Disable input device
void CInputDevice::DisableDevice(void)
{
	// if device is already disabled 
	if(!id_bDeviceEnabled) {
		// return
		return;
	}


	ClearControlsValue();
	id_bDeviceEnabled = FALSE;
}

// Enable given control
void CInputDevice::EnableControl(INDEX iControl)
{
	id_aicControls[iControl].ic_bExisting = TRUE;
}

// Disable given control
void CInputDevice::DisableControl(INDEX iControl)
{
	id_aicControls[iControl].ic_bExisting = FALSE;
}

// Init device as none
static BOOL InitDeviceAsNone(CInputDevice &idDevice)
{
	ASSERT(idDevice.id_dtDeviceType==DT_NONE);
	ASSERT(idDevice.id_aicControls.Count() == 0);
	// set device name
	idDevice.id_strDeviceName = "None";
	idDevice.id_strDeviceShortName = "";
	// allow control none
	idDevice.id_aicControls.New(1);
	return TRUE;
}

// Init device as keyboard
static BOOL InitDeviceAsKeyboard(CInputDevice &idDevice)
{
	ASSERT(idDevice.id_dtDeviceType==DT_NONE);
	ASSERT(idDevice.id_aicControls.Count() == 0);

	// set device type
	idDevice.id_dtDeviceType = DT_KEYBOARD;
	// allocate input controls for device
	idDevice.id_aicControls.New(CT_KEYBOARD_CONTROLS);

	// set device name
	idDevice.id_strDeviceName = "Keyboard";
	idDevice.id_strDeviceShortName = "";

	// Disable mouse keys in keyboard
	idDevice.DisableControl(KID_MOUSE1);
	idDevice.DisableControl(KID_MOUSE2);
	idDevice.DisableControl(KID_MOUSE3);
	idDevice.DisableControl(KID_MOUSE4);
	idDevice.DisableControl(KID_MOUSE5);
	idDevice.DisableControl(KID_MOUSEWHEELUP);
	idDevice.DisableControl(KID_MOUSEWHEELDOWN);
	idDevice.DisableControl(KID_2MOUSE1);
	idDevice.DisableControl(KID_2MOUSE2);
	idDevice.DisableControl(KID_2MOUSE3);
	return TRUE;
}

// Init device as mouse
static BOOL InitDeviceAsMouse(CInputDevice &idDevice)
{
	ASSERT(idDevice.id_dtDeviceType==DT_NONE);
	ASSERT(idDevice.id_aicControls.Count() == 0);

	// set device type
	idDevice.id_dtDeviceType = DT_MOUSE;
	// allocate input controls for device
	idDevice.id_aicControls.New(CT_MOUSE_CONTROLS);

	// set device name
	idDevice.id_strDeviceName = "Mouse";
	idDevice.id_strDeviceShortName = "";
	return TRUE;
}

// Init device as second mouse
static BOOL InitDeviceAsSecondMouse(CInputDevice &idDevice)
{
	ASSERT(idDevice.id_dtDeviceType==DT_NONE);
	ASSERT(idDevice.id_aicControls.Count() == 0);
	
	// set device type
	idDevice.id_dtDeviceType = DT_SECOND_MOUSE;
	// allocate input controls for device
	idDevice.id_aicControls.New(CT_SECOND_MOUSE_CONTROLS);

	// set device name
	idDevice.id_strDeviceName = "Second mouse";
	idDevice.id_strDeviceShortName = "Mouse2";

	return TRUE;
}

// Init devices as joystick
static BOOL InitDeviceAsJoystick(CInputDevice &idDevice)
{
	ASSERT(idDevice.id_dtDeviceType==DT_NONE);
	ASSERT(idDevice.id_aicControls.Count() == 0);

	// Set device type
	idDevice.id_dtDeviceType = DT_JOYSTICK;
	// Allocate input controls for device
	idDevice.id_aicControls.New(CT_JOYSTICK_CONTROLS);


	// get joystick index
	INDEX iJoy = idDevice.id_iDeviceIndex - FIRST_JOYSTICK_DEVICE;

	// set device name
	idDevice.id_strDeviceName.PrintF("Joystick %d",iJoy+1); // jc.szPname;
	idDevice.id_strDeviceShortName.PrintF("Joy %d",iJoy+1);

	JOYCAPS jc;
	CPrintF(TRANS("  joy %d:"), iJoy+1);

	// seek for capabilities of requested joystick
	MMRESULT mmResult = joyGetDevCaps( JOYSTICKID1+iJoy,	&jc, sizeof(JOYCAPS));
	// report possible errors
	if( mmResult == MMSYSERR_NODRIVER) {
		CPrintF(TRANS(" joystick driver is not present\n"));
		return FALSE;
	} else if( mmResult == MMSYSERR_INVALPARAM) {
		CPrintF(TRANS(" invalid parameter\n"));
		return FALSE;
	} else if( mmResult != JOYERR_NOERROR) {
		CPrintF(TRANS("  error 0x%08x\n"), mmResult);
		return FALSE;
	}
	CPrintF(" '%s'\n", jc.szPname);
	CPrintF(TRANS("    %d axes\n"), jc.wNumAxes);
	CPrintF(TRANS("    %d buttons\n"), jc.wNumButtons);

	// if joystick has POV
	if (jc.wCaps&JOYCAPS_HASPOV) {
		CPrintF(TRANS("    POV hat present\n"));
		// Enable all pov controls
		idDevice.id_aicControls[FIRST_POV_CONTROL+0].ic_bExisting = TRUE;
		idDevice.id_aicControls[FIRST_POV_CONTROL+1].ic_bExisting = TRUE;
		idDevice.id_aicControls[FIRST_POV_CONTROL+2].ic_bExisting = TRUE;
		idDevice.id_aicControls[FIRST_POV_CONTROL+3].ic_bExisting = TRUE;
	} else {
		// Disable all pov controls
		idDevice.id_aicControls[FIRST_POV_CONTROL+0].ic_bExisting = FALSE;
		idDevice.id_aicControls[FIRST_POV_CONTROL+1].ic_bExisting = FALSE;
		idDevice.id_aicControls[FIRST_POV_CONTROL+2].ic_bExisting = FALSE;
		idDevice.id_aicControls[FIRST_POV_CONTROL+3].ic_bExisting = FALSE;
	}

	// read joystick state
	JOYINFOEX ji;
	ji.dwSize  = sizeof( JOYINFOEX);
	ji.dwFlags = JOY_RETURNBUTTONS|JOY_RETURNCENTERED|JOY_RETURNPOV|JOY_RETURNR|
							 JOY_RETURNX|JOY_RETURNY|JOY_RETURNZ|JOY_RETURNU|JOY_RETURNV;
	
	mmResult = joyGetPosEx( JOYSTICKID1+iJoy, &ji);

	// if some error
	if( mmResult != JOYERR_NOERROR) {
		// fail
		CPrintF(TRANS("    Cannot read the joystick!\n"));
		return FALSE;
	}

	// X axis
	idDevice.id_aicControls[ 0].ic_bExisting = TRUE;
	idDevice.id_aicControls[ 1].ic_bExisting = TRUE;
	idDevice.id_aicControls[ 0].ic_slMin = jc.wXmin; idDevice.id_aicControls[ 0].ic_slMax = jc.wXmax;
	idDevice.id_aicControls[ 1].ic_slMin = jc.wXmin; idDevice.id_aicControls[ 1].ic_slMax = jc.wXmax;

	// Y axis
	idDevice.id_aicControls[ 2].ic_bExisting = TRUE;
	idDevice.id_aicControls[ 3].ic_bExisting = TRUE;
	idDevice.id_aicControls[ 2].ic_slMin = jc.wYmin; idDevice.id_aicControls[ 2].ic_slMax = jc.wYmax;
	idDevice.id_aicControls[ 3].ic_slMin = jc.wYmin; idDevice.id_aicControls[ 3].ic_slMax = jc.wYmax;
	// Z axis
	idDevice.id_aicControls[ 4].ic_bExisting = jc.wCaps&JOYCAPS_HASZ;
	idDevice.id_aicControls[ 5].ic_bExisting = jc.wCaps&JOYCAPS_HASZ;
	idDevice.id_aicControls[ 4].ic_slMin = jc.wZmin; idDevice.id_aicControls[ 4].ic_slMax = jc.wZmax;
	idDevice.id_aicControls[ 5].ic_slMin = jc.wZmin; idDevice.id_aicControls[ 5].ic_slMax = jc.wZmax;
	// R axis
	idDevice.id_aicControls[ 6].ic_bExisting = jc.wCaps&JOYCAPS_HASR;
	idDevice.id_aicControls[ 7].ic_bExisting = jc.wCaps&JOYCAPS_HASR;
	idDevice.id_aicControls[ 6].ic_slMin = jc.wRmin; idDevice.id_aicControls[ 6].ic_slMax = jc.wRmax;
	idDevice.id_aicControls[ 7].ic_slMin = jc.wRmin; idDevice.id_aicControls[ 7].ic_slMax = jc.wRmax;
	// U axis
	idDevice.id_aicControls[ 8].ic_bExisting = jc.wCaps&JOYCAPS_HASU;
	idDevice.id_aicControls[ 9].ic_bExisting = jc.wCaps&JOYCAPS_HASU;
	idDevice.id_aicControls[ 8].ic_slMin = jc.wUmin; idDevice.id_aicControls[ 8].ic_slMax = jc.wUmax;
	idDevice.id_aicControls[ 9].ic_slMin = jc.wUmin; idDevice.id_aicControls[ 9].ic_slMax = jc.wUmax;
	// V axis
	idDevice.id_aicControls[10].ic_bExisting = jc.wCaps&JOYCAPS_HASV;
	idDevice.id_aicControls[11].ic_bExisting = jc.wCaps&JOYCAPS_HASV;
	idDevice.id_aicControls[10].ic_slMin = jc.wVmin; idDevice.id_aicControls[10].ic_slMax = jc.wVmax;
	idDevice.id_aicControls[11].ic_slMin = jc.wVmin; idDevice.id_aicControls[11].ic_slMax = jc.wVmax;
	return TRUE;
}


BOOL CInputDevice::InitDevice(DeviceType dtDeviceType)
{
	switch( dtDeviceType )
	{
	case DT_NONE:
		return InitDeviceAsNone(*this);
		break;
	case DT_KEYBOARD:
		return InitDeviceAsKeyboard(*this);
		break;
	case DT_MOUSE:
		return InitDeviceAsMouse(*this);
		break;
	case DT_SECOND_MOUSE:
		return InitDeviceAsSecondMouse(*this);
		break;
	case DT_JOYSTICK:
		return InitDeviceAsJoystick(*this);
		break;
	default:
		ASSERTALWAYS("Unknown device type");
		return FALSE;
		break;
	}
}

static void SetKeyboardControlNames(CInputDevice &idDevice)
{
	ASSERT(idDevice.id_aicControls.Count() == CT_KEYBOARD_CONTROLS);
	ASSERT(idDevice.id_dtDeviceType == DT_KEYBOARD);

	// set name "None" for all keyboard controls , known controls will override this default name
	INDEX ctct = CT_KEYBOARD_CONTROLS;
	INDEX ict;
	for( ict = 0; ict < ctct; ict++ ) 
	{
		InputControl &icControl = idDevice.id_aicControls[ict];
		icControl.ic_strControlName = "None";
		icControl.ic_strControlNameTrans = TRANS("None");
	}

	// for each Key
	ctct = ARRAYCOUNT(_akcKeys);
	for( ict = 0; ict < ctct; ict++) 
	{
		struct KeyConversion &kc = _akcKeys[ict];
		// set the name
		if(kc.kc_strName!=NULL) {
			InputControl &icControl = idDevice.id_aicControls[kc.kc_iKID];
			icControl.ic_strControlName = kc.kc_strName;

			if(strlen(kc.kc_strNameTrans)==0) {
				icControl.ic_strControlNameTrans = kc.kc_strName;
			} else {
				icControl.ic_strControlNameTrans = TranslateConst(kc.kc_strNameTrans, 4);
			}
		}
	}
}

static void SetMouseControlNames(CInputDevice &idDevice)
{
	ASSERT(idDevice.id_aicControls.Count() == CT_MOUSE_CONTROLS);
	ASSERT(idDevice.id_dtDeviceType == DT_MOUSE);

	idDevice.id_aicControls[CID_MOUSE_AXIS_XP].ic_strControlName      = "Mouse X+";
	idDevice.id_aicControls[CID_MOUSE_AXIS_XP].ic_strControlNameTrans = TRANS("mouse X+");
	idDevice.id_aicControls[CID_MOUSE_AXIS_XN].ic_strControlName      = "Mouse X-";
	idDevice.id_aicControls[CID_MOUSE_AXIS_XN].ic_strControlNameTrans = TRANS("mouse X-");
	idDevice.id_aicControls[CID_MOUSE_AXIS_YP].ic_strControlName      = "Mouse Y+";
	idDevice.id_aicControls[CID_MOUSE_AXIS_YP].ic_strControlNameTrans = TRANS("mouse Y+");
	idDevice.id_aicControls[CID_MOUSE_AXIS_YN].ic_strControlName      = "Mouse Y-";
	idDevice.id_aicControls[CID_MOUSE_AXIS_YN].ic_strControlNameTrans = TRANS("mouse Y-");
	idDevice.id_aicControls[CID_MOUSE_WHEEL_UP].ic_strControlName      = "Mouse Wheel Up";
	idDevice.id_aicControls[CID_MOUSE_WHEEL_UP].ic_strControlNameTrans = TRANS("Mouse Wheel Up");
	idDevice.id_aicControls[CID_MOUSE_WHEEL_DOWN].ic_strControlName      = "Mouse Wheel Down";
	idDevice.id_aicControls[CID_MOUSE_WHEEL_DOWN].ic_strControlNameTrans = TRANS("Mouse Wheel Down");
	
	// for each mouse button
	INDEX ctbtn = CT_MOUSE_BUTTONS;
	for(INDEX ibtn=0;ibtn<ctbtn;ibtn++) {
		// set its name
		InputControl &icContorol = idDevice.id_aicControls[FIRST_MOUSE_BUTTON+ibtn];
		CTString strButtonName;
		strButtonName.PrintF("Button %d",ibtn+1);
		icContorol.ic_strControlName      = strButtonName;
		icContorol.ic_strControlNameTrans = TRANSV(strButtonName);
	}
}

static void SetSecondMouseControlNames(CInputDevice &idDevice)
{
	ASSERT(idDevice.id_aicControls.Count() == CT_SECOND_MOUSE_CONTROLS);
	ASSERT(idDevice.id_dtDeviceType == DT_SECOND_MOUSE);

	idDevice.id_aicControls[CID_MOUSE2_AXIS_XP].ic_strControlName      = "Mouse X+";
	idDevice.id_aicControls[CID_MOUSE2_AXIS_XP].ic_strControlNameTrans = TRANS("mouse X+");
	idDevice.id_aicControls[CID_MOUSE2_AXIS_XN].ic_strControlName      = "Mouse X-";
	idDevice.id_aicControls[CID_MOUSE2_AXIS_XN].ic_strControlNameTrans = TRANS("mouse X-");
	idDevice.id_aicControls[CID_MOUSE2_AXIS_YP].ic_strControlName      = "Mouse Y+";
	idDevice.id_aicControls[CID_MOUSE2_AXIS_YP].ic_strControlNameTrans = TRANS("mouse Y+");
	idDevice.id_aicControls[CID_MOUSE2_AXIS_YN].ic_strControlName      = "Mouse Y-";
	idDevice.id_aicControls[CID_MOUSE2_AXIS_YN].ic_strControlNameTrans = TRANS("mouse Y-");

	// for each mouse button
	INDEX ctbtn = CT_SECOND_MOUSE_BUTTONS;
	for(INDEX ibtn=0;ibtn<ctbtn;ibtn++) {
		// set its name
		InputControl &icContorol = idDevice.id_aicControls[FIRST_SECOND_MOUSE_BUTTON+ibtn];
		CTString strButtonName;
		strButtonName.PrintF("button %d",ibtn+1);
		icContorol.ic_strControlName      = strButtonName;
		icContorol.ic_strControlNameTrans = TRANSV(strButtonName);
	}
}

static void SetJoystickControlNames(CInputDevice &idDevice)
{
	ASSERT(idDevice.id_aicControls.Count() == CT_JOYSTICK_CONTROLS);
	ASSERT(idDevice.id_dtDeviceType == DT_JOYSTICK);

	idDevice.id_aicControls[CID_JOY_AXIS_XP].ic_strControlName      = "Axis X+";
	idDevice.id_aicControls[CID_JOY_AXIS_XP].ic_strControlNameTrans = TRANS("Axis X+");
	idDevice.id_aicControls[CID_JOY_AXIS_XN].ic_strControlName      = "Axis X-";
	idDevice.id_aicControls[CID_JOY_AXIS_XN].ic_strControlNameTrans = TRANS("Axis X-");
	idDevice.id_aicControls[CID_JOY_AXIS_YP].ic_strControlName      = "Axis Y+";
	idDevice.id_aicControls[CID_JOY_AXIS_YP].ic_strControlNameTrans = TRANS("Axis Y+");
	idDevice.id_aicControls[CID_JOY_AXIS_YN].ic_strControlName      = "Axis Y-";
	idDevice.id_aicControls[CID_JOY_AXIS_YN].ic_strControlNameTrans = TRANS("Axis Y-");
	idDevice.id_aicControls[CID_JOY_AXIS_ZP].ic_strControlName      = "Axis Z+";
	idDevice.id_aicControls[CID_JOY_AXIS_ZP].ic_strControlNameTrans = TRANS("Axis Z+");
	idDevice.id_aicControls[CID_JOY_AXIS_ZN].ic_strControlName      = "Axis Z-";
	idDevice.id_aicControls[CID_JOY_AXIS_ZN].ic_strControlNameTrans = TRANS("Axis Z-");
	idDevice.id_aicControls[CID_JOY_AXIS_RP].ic_strControlName      = "Axis R+";
	idDevice.id_aicControls[CID_JOY_AXIS_RP].ic_strControlNameTrans = TRANS("Axis R+");
	idDevice.id_aicControls[CID_JOY_AXIS_RN].ic_strControlName      = "Axis R-";
	idDevice.id_aicControls[CID_JOY_AXIS_RN].ic_strControlNameTrans = TRANS("Axis R-");
	idDevice.id_aicControls[CID_JOY_AXIS_UP].ic_strControlName      = "Axis U+";
	idDevice.id_aicControls[CID_JOY_AXIS_UP].ic_strControlNameTrans = TRANS("Axis U+");
	idDevice.id_aicControls[CID_JOY_AXIS_UN].ic_strControlName      = "Axis U-";
	idDevice.id_aicControls[CID_JOY_AXIS_UN].ic_strControlNameTrans = TRANS("Axis U-");
	idDevice.id_aicControls[CID_JOY_AXIS_VP].ic_strControlName      = "Axis V+";
	idDevice.id_aicControls[CID_JOY_AXIS_VP].ic_strControlNameTrans = TRANS("Axis V+");
	idDevice.id_aicControls[CID_JOY_AXIS_VN].ic_strControlName      = "Axis V-";
	idDevice.id_aicControls[CID_JOY_AXIS_VN].ic_strControlNameTrans = TRANS("Axis V-");

	// for each button
	INDEX ctbtn = CT_JOYSTICK_BUTTONS;
	for(INDEX ibtn=0;ibtn<ctbtn;ibtn++) {
		InputControl &icControl = idDevice.id_aicControls[ibtn+FIRST_JOYSTICK_BUTTON];
		CTString strButtonName;
		CTString strButtonNameTrans;
		strButtonName.PrintF("button %d",ibtn+1);
		strButtonNameTrans.PrintF("%s %d",TRANS("button"),ibtn+1);
		icControl.ic_strControlName      = strButtonName;
		icControl.ic_strControlNameTrans = strButtonNameTrans;
	}
	// for each POV button
	idDevice.id_aicControls[CID_JOY_POV_N].ic_strControlName = "POV N";
	idDevice.id_aicControls[CID_JOY_POV_N].ic_strControlNameTrans = TRANS("POV N");
	idDevice.id_aicControls[CID_JOY_POV_E].ic_strControlName = "POV E";
	idDevice.id_aicControls[CID_JOY_POV_E].ic_strControlNameTrans = TRANS("POV E");
	idDevice.id_aicControls[CID_JOY_POV_S].ic_strControlName = "POV S";
	idDevice.id_aicControls[CID_JOY_POV_S].ic_strControlNameTrans = TRANS("POV S");
	idDevice.id_aicControls[CID_JOY_POV_W].ic_strControlName = "POV W";
	idDevice.id_aicControls[CID_JOY_POV_W].ic_strControlNameTrans = TRANS("POV W");
}


static void SetNoneControlNames(CInputDevice &idDevice)
{
	idDevice.id_aicControls[0].ic_strControlName = "None";
	idDevice.id_aicControls[0].ic_strControlNameTrans = TRANS("None");
}

void CInput::SetControlNames(void)
{
	// for each input device
	INDEX ctid = inp_aInputDevices.Count();
	for(INDEX iid=0;iid<ctid;iid++) {
		CInputDevice &idDevice = inp_aInputDevices[iid];
		switch(idDevice.id_dtDeviceType) {
			case DT_KEYBOARD:
				SetKeyboardControlNames(idDevice);
			break;
			case DT_MOUSE:
				SetMouseControlNames(idDevice);
			break;
			case DT_SECOND_MOUSE:
				SetSecondMouseControlNames(idDevice);
			break;
			case DT_JOYSTICK:
				SetJoystickControlNames(idDevice);
			break;
			case DT_NONE:
				SetNoneControlNames(idDevice);
			break;
			default:
				ASSERTALWAYS("Unknown device type");
			break;
		}
	}
}



// Converts kid to char (use only with keyboard device)
extern char GetCharFromKey(ULONG ulControlGID, BOOL bShift)
{
	INDEX iControlLid = GetControlLID(ulControlGID);
		ASSERT(GetInputDeviceID(ulControlGID)==KEYBOARD_DEVICE);
	ASSERT(iControlLid>=0 && iControlLid<ARRAYCOUNT(_achKidToChar));
	// if shift is pressed 
	if(bShift) {
		return _achKidToShiftChar[iControlLid];
	} else {
		return _achKidToChar[iControlLid];
	}
}

// Converts char to kid (use only with keyboard device) (unoptimized)
extern ULONG GetGIDFromChar(char ch)
{
	// for each kid
	INDEX ctkids = ARRAYCOUNT(_achKidToChar);
	for(INDEX ikid=0;ikid<ctkids;ikid++) {
		if(_achKidToChar[ikid] == ch) {
			return GetControlGID(KEYBOARD_DEVICE,ikid);
		}
	}
	return CONTROL_NONE;
}

// Converts virtual key to gid
extern ULONG GetGIDFromVirtKey(INDEX iVirt)
{
	ASSERT(iVirt>=0 && iVirt<ARRAYCOUNT(_aiVirtToKid));
	INDEX iKid = _aiVirtToKid[iVirt];
	return GetControlGID(KEYBOARD_DEVICE,iKid);
}

// sehan
//BOOL g_bUseBloom = FALSE;
//int g_iFilterNum = 0;
// sehan end

static void ReadKeyboardDevice(CInputDevice &idDevice, BOOL bPreScan)
{
	// if not pre-scanning
	if (!bPreScan) {
		idDevice.ClearControlsValue();

		// for each Key
		for (INDEX iKey=0; iKey<ARRAYCOUNT(_akcKeys); iKey++) {
			struct KeyConversion &kc = _akcKeys[iKey];
			// get codes
			INDEX iKID  = kc.kc_iKID;
			INDEX iScan = kc.kc_iScanCode;
			INDEX iVirt = kc.kc_iVirtKey;

			// if reading async keystate
			if (inp_iKeyboardReadingMethod==0) {
				// if there is a valid virtkey
				if (iVirt>=0) {
					// transcribe if modifier
					if (iVirt == VK_LSHIFT) {
						iVirt = VK_SHIFT;
					}
					if (iVirt == VK_LCONTROL) {
						iVirt = VK_CONTROL;
					}
					if (iVirt == VK_LMENU) {
						iVirt = VK_MENU;
					}
					// is state is pressed
					if (GetAsyncKeyState(iVirt)&0x8000) {
						// mark it as pressed
						idDevice.id_aicControls[iKID].ic_fValue = 1.0f;
					}
				}		
			// if snooping messages
			} else {
				
				if (_abKeysPressed[KID_LSHIFT]) {
					// mark it as pressed
					idDevice.id_aicControls[KID_LSHIFT].ic_fValue = 1.0f;
				}

				//0105
				if(_pInput->m_bTcpIp){
					if(_pInput->m_bForward){
						idDevice.id_aicControls[KID_W].ic_fValue = 1.0f;
						//	_pInput->m_bForward = FALSE;
						//		  return;
					}
				}//tcp끝

				if (_abKeysPressed[KID_MOUSE2]) 
				{ 
					if(!_pInput->m_bPressedRMouse){
						
						_pInput->m_bPressedRMouse = TRUE; //press 상태이다.
						if(!_pInput->IsRMousePressed()){	//토글			
							_pInput->SetRMousePressed(TRUE);						
						}else{
							_pInput->SetRMousePressed(FALSE);	
						}					  
					}else //계속 press상태이다.
					{					  
					}			  
				}
				else{ //unPress상태가 되었다.
					_pInput->m_bPressedRMouse = FALSE;
				}
				
				if (_abKeysPressed[KID_MOUSE1]) 
				{ 
					if(!_pInput->m_bPressedLMouse){
						
						_pInput->m_bPressedLMouse = TRUE; //press 상태이다.
						if(!_pInput->IsLMousePressed()){	//토글			
							_pInput->SetLMousePressed(TRUE);						
						}else{
							_pInput->SetLMousePressed(FALSE);	
						}					  
					}else //계속 press상태이다.
					{					  
					}			  
				}
				else{ //unPress상태가 되었다.
					_pInput->m_bPressedLMouse = FALSE;
				}

				if (_abKeysPressed[KID_HOME]) 
				{ 
					if(!_pInput->m_bPressedHome){
						
						_pInput->m_bPressedHome = TRUE; //press 상태이다.
						if(!_pInput->IsHomePressed()){	//토글			
							_pInput->SetHomePressed(TRUE);						
						}else{
							_pInput->SetHomePressed(FALSE);	
						}					  
					}else //계속 press상태이다.
					{					  
					}			  
				}
				else{ //unPress상태가 되었다.
					_pInput->m_bPressedHome = FALSE;
				}

				//0819
				if(_abKeysPressed[KID_1]){//
					if(!_pInput->m_bPressed1Key){
						_pInput->m_bPressed1Key = TRUE;
						if(!_pInput->IsNum1KeyPressed()){	//토글
							_pInput->SetNum1KeyPressed(TRUE);
						}else{
							_pInput->SetNum1KeyPressed(FALSE);
						}
					}else
					{
					}
				}
				else{
					_pInput->m_bPressed1Key = FALSE;
				}
				
				if(_abKeysPressed[KID_MOUSE3]){
					if(!_pInput->m_bPressedWheel){
						_pInput->m_bPressedWheel = TRUE;
						if(!_pInput->IsWheelPressed()){
							_pInput->SetWheelPressed(TRUE);
						}else{
							_pInput->SetWheelPressed(FALSE);
						}
					}else
					{
					}
				}
				else{
					_pInput->m_bPressedWheel = FALSE;
				}
				
				if(_abKeysPressed[KID_2]){
					if(!_pInput->m_bPressed2Key){
						_pInput->m_bPressed2Key = TRUE;
						if(!_pInput->IsNum2KeyPressed()){	//토글
							_pInput->SetNum2KeyPressed(TRUE);
						}else{
							_pInput->SetNum2KeyPressed(FALSE);
						}
					}else
					{
					}
				}
				else{
					_pInput->m_bPressed2Key = FALSE;
				}

				if(_abKeysPressed[KID_3]){
					if(!_pInput->m_bPressed3Key){
						_pInput->m_bPressed3Key = TRUE;
						if(!_pInput->IsNum3KeyPressed()){	//토글
							_pInput->SetNum3KeyPressed(TRUE);
						}else{
							_pInput->SetNum3KeyPressed(FALSE);
						}
					}else
					{
					}
				}
				else{
					_pInput->m_bPressed3Key = FALSE;
				}
				
				if (_abKeysPressed[KID_SPACE]) {
					// mark it as pressed
					idDevice.id_aicControls[KID_SPACE].ic_fValue = 1.0f;
				}

				if (_abKeysPressed[KID_ARROWLEFT]) {
					// mark it as pressed
					idDevice.id_aicControls[KID_ARROWLEFT].ic_fValue = 1.0f;
				}
				if (_abKeysPressed[KID_ARROWRIGHT]) {
					// mark it as pressed
					idDevice.id_aicControls[KID_ARROWRIGHT].ic_fValue = 1.0f;
				}
				if (_abKeysPressed[KID_ARROWDOWN]) {
					// mark it as pressed
					idDevice.id_aicControls[KID_ARROWDOWN].ic_fValue = 1.0f;
				}
				if (_abKeysPressed[KID_ARROWUP]) {
					// mark it as pressed
					idDevice.id_aicControls[KID_ARROWUP].ic_fValue = 1.0f;
				}
			
				if (_abKeysPressed[KID_NUM4]) {
					// mark it as pressed
					idDevice.id_aicControls[KID_NUM4].ic_fValue = 1.0f;
				}
				if (_abKeysPressed[KID_NUM6]) {
					// mark it as pressed
					idDevice.id_aicControls[KID_NUM6].ic_fValue = 1.0f;
				}
				if (_abKeysPressed[KID_NUM8]) {
					// mark it as pressed
					idDevice.id_aicControls[KID_NUM8].ic_fValue = 1.0f;
				}
				if (_abKeysPressed[KID_NUM2]) {
					// mark it as pressed
					idDevice.id_aicControls[KID_NUM2].ic_fValue = 1.0f;
				}
				// wooss zoom in/out key mapping
				if (_abKeysPressed[KID_PAGEUP]) {
					idDevice.id_aicControls[KID_PAGEUP].ic_fValue = 1.0f;
				}
				if (_abKeysPressed[KID_PAGEDOWN]) {
					idDevice.id_aicControls[KID_PAGEDOWN].ic_fValue = 1.0f;
				}
				if (_abKeysPressed[KID_W]) {
					idDevice.id_aicControls[KID_W].ic_fValue = 1.0f;
				}
				if (_abKeysPressed[KID_S]) {
					idDevice.id_aicControls[KID_S].ic_fValue = 1.0f;
				}
				if (_abKeysPressed[KID_Q]) {
					idDevice.id_aicControls[KID_Q].ic_fValue = 1.0f;
				}
				if (_abKeysPressed[KID_E]) {
					idDevice.id_aicControls[KID_E].ic_fValue = 1.0f;
				}
				if (_abKeysPressed[KID_A]) {
					idDevice.id_aicControls[KID_A].ic_fValue = 1.0f;
				}
				if (_abKeysPressed[KID_D]) {
					idDevice.id_aicControls[KID_D].ic_fValue = 1.0f;
				}

				/*
				if(_pNetwork->m_ubGMLevel > 1)
				{
					
					
					if (_abKeysPressed[KID_LCONTROL]) { //L컨트롤 키가 눌러져있다면,
						if(!_pInput->m_bPressedLControlKey ){//unPress상태에서 처음 Press된거라면,
							//_pInput->m_bLControlKey = TRUE; 
							_pInput->m_bPressedLControlKey = TRUE; //press 상태이다.
							if(!_pInput->IsLControlKeyPressed()){	//토글			
								_pInput->SetLControlKeyPressed(TRUE);						
							}else{
								_pInput->SetLControlKeyPressed(FALSE);	
							}					  
						}else //계속 press상태이다.
						{					  
						}			  
					}
					else{ //unPress상태가 되었다.
						_pInput->m_bPressedLControlKey = FALSE;
					}
					
					
					if(_abKeysPressed[KID_R]){
						if(!_pInput->m_bPressedRKey){//unPress상태에서 처음 Press된거라면,
							_pInput->m_bPressedRKey = TRUE; //press 상태이다.
							if(!_pInput->m_bRKey){	//토글
								_pInput->m_bRKey =TRUE;
								// _pInput->m_bTcpIp =TRUE;
							}else{
								_pInput->m_bRKey =FALSE;
								//_pInput->m_bTcpIp = FALSE;
							}
						}else //계속 press상태이다.
						{
						}
					}
					else{ //unPress상태가 되었다.
						_pInput->m_bPressedRKey = FALSE;
					}					
					
					if(_abKeysPressed[KID_V]){
						if(!_pInput->m_bPressedVKey){
							_pInput->m_bPressedVKey = TRUE;
							if(!_pInput->IsVKeyPressed()){
								_pInput->SetVKeyPressed(TRUE);
								//0605 kwon 삭제.
								_pInput->m_bTcpIp =FALSE;
								//		_pInput->m_bTcpIp =TRUE;
							}else{
								_pInput->SetVKeyPressed(FALSE);
								_pInput->m_bTcpIp =TRUE;
								//		_pInput->m_bTcpIp =FALSE;
							}
						}else
						{
						}
					}
					else{
						_pInput->m_bPressedVKey = FALSE;
					}					
					
					if (_abKeysPressed[KID_LCONTROL]) { //L컨트롤 키가 눌러져있다면,
						if(_abKeysPressed[KID_M]){
							if(!_pInput->m_bPressedMKey){
								_pInput->m_bPressedMKey = TRUE;
								if(!_pInput->IsMKeyPressed()){
									_pInput->SetMKeyPressed(TRUE);
								}else{
									_pInput->SetMKeyPressed(FALSE);
								}
							}else
							{
							}
						}
						else{
							_pInput->m_bPressedMKey = FALSE;
						}
						
						
						if(_abKeysPressed[KID_F2]){
							if(!_pInput->m_bPressedF2Key){
								_pInput->m_bPressedF2Key = TRUE;
								if(!_pInput->IsF2KeyPressed()){
									_pInput->SetF2KeyPressed(TRUE);
								}else{
									_pInput->SetF2KeyPressed(FALSE);
								}
							}else
							{
							}
						}
						else{
							_pInput->m_bPressedF2Key = FALSE;
						}
						
						if(_abKeysPressed[KID_F3]){
							if(!_pInput->m_bPressedF3Key){
								_pInput->m_bPressedF3Key = TRUE;
								if(!_pInput->IsF3KeyPressed()){
									_pInput->SetF3KeyPressed(TRUE);
								}else{
									_pInput->SetF3KeyPressed(FALSE);
								}
							}else
							{
							}
						}
						else{
							_pInput->m_bPressedF3Key = FALSE;
						}
						
						if(_abKeysPressed[KID_U]){
							if(!_pInput->m_bPressedUKey){
								_pInput->m_bPressedUKey = TRUE;
								if(!_pInput->IsUKeyPressed()){
									_pInput->SetUKeyPressed(TRUE);
								}else{
									_pInput->SetUKeyPressed(FALSE);
								}
							}else
							{
							}
						}
						else{
							_pInput->m_bPressedUKey = FALSE;
						}
						
						if(_abKeysPressed[KID_Q]){
							if(!_pInput->m_bPressedQKey){
								_pInput->m_bPressedQKey = TRUE;
								if(!_pInput->IsQKeyPressed()){
									_pInput->SetQKeyPressed(TRUE);
								}else{
									_pInput->SetQKeyPressed(FALSE);
								}
							}else
							{
							}
						}
						else{
							_pInput->m_bPressedQKey = FALSE;
						}
						
						if(_abKeysPressed[KID_O]){
							if(!_pInput->m_bPressedOKey){
								_pInput->m_bPressedOKey = TRUE;
								if(!_pInput->IsOKeyPressed()){
									_pInput->SetOKeyPressed(TRUE);
									g_fGWTimeMul = 0;
									//  g_fGWTime = 54000.0f;
								}else{
									_pInput->SetOKeyPressed(FALSE);
									g_fGWTimeMul = 1;
								}
							}else
							{
							}
						}
						else{
							_pInput->m_bPressedOKey = FALSE;
						}
																						
						
						//0322 kwon
						if(_abKeysPressed[KID_4]){
							if(!_pInput->m_bPressed4Key){
								_pInput->m_bPressed4Key = TRUE;
								if(!_pInput->IsNum4KeyPressed()){	//토글
									_pInput->SetNum4KeyPressed(TRUE);
								}else{
									_pInput->SetNum4KeyPressed(FALSE);
								}
							}else
							{
							}
						}
						else{
							_pInput->m_bPressed4Key = FALSE;
						}
						
						if(_abKeysPressed[KID_5]){
							if(!_pInput->m_bPressed5Key){
								_pInput->m_bPressed5Key = TRUE;
								if(!_pInput->IsNum5KeyPressed()){
									_pInput->SetNum5KeyPressed(TRUE);
									g_fGWTimeMul = 30.0f;
								}else{
									_pInput->SetNum5KeyPressed(FALSE);
									g_fGWTimeMul = 1.0f;
								}
							}else
							{
							}
						}
						else{
							_pInput->m_bPressed5Key = FALSE;
						}
						
						if(_abKeysPressed[KID_6]){
							if(!_pInput->m_bPressed6Key){
								_pInput->m_bPressed6Key = TRUE;
								if(!_pInput->IsNum6KeyPressed()){
									_pInput->SetNum6KeyPressed(TRUE);
									g_fGWTime = 54000.0f;
								}else{
									_pInput->SetNum6KeyPressed(FALSE);
									g_fGWTime = 18000.0f;
								}
							}else
							{
							}
						}
						else{
							_pInput->m_bPressed6Key = FALSE;
						}
					}
					if(_abKeysPressed[KID_I]){
						if(!_pInput->m_bPressedIKey){//unPress상태에서 처음 Press된거라면,
							_pInput->m_bPressedIKey = TRUE; //press 상태이다.
							if(!_pInput->m_bIKey){	//토글
								_pInput->m_bIKey =TRUE;
							}else{
								_pInput->m_bIKey =FALSE;
							}
						}else //계속 press상태이다.
						{
						}
					}
					else{ //unPress상태가 되었다.
						_pInput->m_bPressedIKey = FALSE;
					}
					
					// sehan
					if(_abKeysPressed[KID_L]){
						if(!_pInput->m_bPressedLKey){//unPress상태에서 처음 Press된거라면,
							_pInput->m_bPressedLKey = TRUE; //press 상태이다.
							if(!_pInput->m_bLKey){	//토글
								_pInput->m_bLKey =TRUE;
								// _pInput->m_bTcpIp =TRUE;
								//g_bUseBloom = TRUE;
							}else{
								_pInput->m_bLKey =FALSE;
								//_pInput->m_bTcpIp = FALSE;
								//g_bUseBloom = FALSE;
							}
						}else //계속 press상태이다.
						{
						}
					}
					else{ //unPress상태가 되었다.
						_pInput->m_bPressedLKey = FALSE;
					}
					// sehan end
					
					if(_abKeysPressed[KID_J]){
						if(!_pInput->m_bPressedJKey){//unPress상태에서 처음 Press된거라면,
							_pInput->m_bPressedJKey = TRUE; //press 상태이다.
							if(!_pInput->m_bJKey){	//토글
								_pInput->m_bJKey =TRUE;
							}else{
								_pInput->m_bJKey =FALSE;
							}
						}else //계속 press상태이다.
						{
						}
					}
					else{ //unPress상태가 되었다.
						_pInput->m_bPressedJKey = FALSE;
					}
					
					if(_abKeysPressed[KID_K]){
						if(!_pInput->m_bPressedKKey){//unPress상태에서 처음 Press된거라면,
							_pInput->m_bPressedKKey = TRUE; //press 상태이다.
							if(!_pInput->m_bKKey){	//토글
								_pInput->m_bKKey =TRUE;
							}else{
								_pInput->m_bKKey =FALSE;
							}
							// sehan
							//g_iFilterNum++;
							//if (g_iFilterNum > 1)
							//	g_iFilterNum = 0;
							// sehan end
						}else //계속 press상태이다.
						{
						}
					}
					else{ //unPress상태가 되었다.
						_pInput->m_bPressedKKey = FALSE;
					}
					
					if(_abKeysPressed[KID_P]){
						if(!_pInput->m_bPressedPKey){//unPress상태에서 처음 Press된거라면,
							_pInput->m_bPressedPKey = TRUE; //press 상태이다.
							if(!_pInput->m_bPKey){	//토글
								_pInput->m_bPKey =TRUE;
							}else{
								_pInput->m_bPKey =FALSE;
							}
						}else //계속 press상태이다.
						{
						}
					}
					else{ //unPress상태가 되었다.
						_pInput->m_bPressedPKey = FALSE;
					}
					
					if(_abKeysPressed[KID_TAB]){
						if(!_pInput->m_bPressedTabKey){//unPress상태에서 처음 Press된거라면,
							//_pInput->m_bLControlKey = TRUE;
							_pInput->m_bPressedTabKey = TRUE; //press 상태이다.
							if(!_pInput->m_bTabKey){	//토글
								_pInput->m_bTabKey =TRUE;
								//	  CPrintF(TRANS("Interface : ON\n"));
							}else{
								_pInput->m_bTabKey =FALSE;
								//	  CPrintF(TRANS("Interface : OFF\n"));
							}
							//		return;
						}else //계속 press상태이다.
						{
							//	_pInput->m_bLControlKey = FALSE;
							//		return;
						}
					}
					else{ //unPress상태가 되었다.
						_pInput->m_bPressedTabKey = FALSE;
					}
					
					// if snooped that key is pressed
					if (_abKeysPressed[iKID]) {
						// mark it as pressed
						idDevice.id_aicControls[iKID].ic_fValue = 1.0f;
					}
				}
				*/
				
			}		
		}
	}
}
/*
//0601 kwon 추가.
static BOOL IsLControlKeyPressing()
{
	if(_abKeysPressed[KID_LCONTROL])
	{
		return TRUE;
	}
	else{
		return FALSE;
	}
}
*/
static void ReadMouseDevice(CInputDevice &idDevice, BOOL bPreScan)
{
	// clear contols's buffer
	idDevice.ClearControlsValue();

	// read mouse position
	POINT pntMouse;
	static POINT pntOldMouse = {0, 0};

	// start seo
	extern BOOL _bInTestGame;
	if (!_bWorldEditorApp || _bInTestGame)		//테스트 게임일 때 아래 루틴을 들어가게 수정 :Su-won
	//if (0) 
	{
		if(_pInput->m_bTcpIp && ((GetCursorPos(&pntMouse)&& _pInput->m_bRButtonDown) ||
			(GetCursorPos(&pntMouse) && _pInput->inp_bFreeMode))) {
	//..
			FLOAT fDX;
			FLOAT fDY;

			if (_pInput->inp_bFreeMode)
			{
				fDX = FLOAT( SLONG(pntMouse.x) - _pInput->inp_slScreenCenterX);
				fDY = FLOAT( SLONG(pntMouse.y) - _pInput->inp_slScreenCenterY);
			}
			else
			{
				fDX = FLOAT( SLONG(pntMouse.x) - pntOldMouse.x);
				fDY = FLOAT( SLONG(pntMouse.y) - pntOldMouse.y);
			}

			pntOldMouse = pntMouse;

			FLOAT fSensitivity = inp_fMouseSensitivity;
			fSensitivity *= 0.25f;
			
			//if ( (fabs(fDX) > 2 && fabs(fDY) > 2) || fabs(fDX) > 3 || fabs(fDY) > 3) {
				FLOAT fD = Sqrt(fDX*fDX+fDY*fDY);
				if (inp_bMousePrecision) {
					static FLOAT _tmTime = 0.0f;
					if( fD<inp_fMousePrecisionThreshold) _tmTime += 0.05f;
					else _tmTime = 0.0f;
					if( _tmTime>inp_fMousePrecisionTimeout) fSensitivity /= inp_fMousePrecisionFactor;
				}

				if (fabs(fDX) >= fabs(fDY))
					fDY = 0.0f;
				else
					fDX = 0.0f;

				static FLOAT fDXOld;
				static FLOAT fDYOld;
				static TIME tmOldDelta;
				static CTimerValue tvBefore;
				CTimerValue tvNow = _pTimer->GetHighPrecisionTimer();
				TIME tmNowDelta = (tvNow-tvBefore).GetSeconds();
				if (tmNowDelta<0.001f) {
					tmNowDelta = 0.001f;
				}
				tvBefore = tvNow;

				FLOAT fDXSmooth = (fDXOld*tmOldDelta+fDX*tmNowDelta)/(tmOldDelta+tmNowDelta);
				FLOAT fDYSmooth = (fDYOld*tmOldDelta+fDY*tmNowDelta)/(tmOldDelta+tmNowDelta);
				fDXOld = fDX;
				fDYOld = fDY;
				tmOldDelta = tmNowDelta;
				//if (inp_bFilterMouse) {
				/*if (1) {
					fDX = fDXSmooth;
					fDY = fDYSmooth;
				}*/

				// get final mouse values
				FLOAT fMouseRelX = +fDX*fSensitivity;
				FLOAT fMouseRelY = -fDY*fSensitivity;
				if (inp_bInvertMouse) {
					fMouseRelY = -fMouseRelY;
				}
				FLOAT fMouseRelZ = _iMouseZ;
		//0105
				if(!_pInput->m_bTcpIp || _pInput->inp_bFreeMode ||
					(_pInput->m_bTcpIp &&_abKeysPressed[KID_MOUSE2] && !_pInput->inp_bFreeMode)){//마우스 휠버튼 DOWN //1211
					idDevice.id_aicControls[0].ic_fValue =  Max(0.0f,fMouseRelX*3/4);
					idDevice.id_aicControls[1].ic_fValue = -Min(0.0f,fMouseRelX*3/4);
					idDevice.id_aicControls[2].ic_fValue =  Max(0.0f,fMouseRelY*3/4);
					idDevice.id_aicControls[3].ic_fValue = -Min(0.0f,fMouseRelY*3/4);
				}
		//..
				// if not pre-scanning
				if (!bPreScan) {
					// detect wheel up/down movement
					if(_iMouseZ>0) {
						if(_bWheelUp) {
							idDevice.id_aicControls[FIRST_MOUSE_SCROLER].ic_fValue = 0.0f;
							_bWheelUp = FALSE;
						} else {
							idDevice.id_aicControls[FIRST_MOUSE_SCROLER].ic_fValue = 1.0f;
							_bWheelUp = TRUE;
							_iMouseZ = ClampDn(_iMouseZ-120, 0);
						}
					}
					if(_iMouseZ<0) {
						if(_bWheelDn) {
							idDevice.id_aicControls[FIRST_MOUSE_SCROLER+1].ic_fValue = 0.0f;
							_bWheelDn = FALSE;
						} else {
							idDevice.id_aicControls[FIRST_MOUSE_SCROLER+1].ic_fValue = 1.0f;
							_bWheelDn = TRUE;
							_iMouseZ = ClampUp(_iMouseZ+120, 0);
						}
					}
				}
			//} // if (fDx > 5 && fDY > 5)
		}

		// if reading async keystate
		if(inp_iKeyboardReadingMethod==0) {
			// Get state for each mouse button
			if(GetAsyncKeyState(VK_LBUTTON)&0x8000) idDevice.id_aicControls[FIRST_MOUSE_BUTTON+0].ic_fValue = 1.0f;
			if(GetAsyncKeyState(VK_RBUTTON)&0x8000) idDevice.id_aicControls[FIRST_MOUSE_BUTTON+1].ic_fValue = 1.0f;
			if(GetAsyncKeyState(VK_MBUTTON)&0x8000) idDevice.id_aicControls[FIRST_MOUSE_BUTTON+2].ic_fValue = 1.0f;
		// if snooping messages
		} else {
			// for each mouse button
			for(INDEX ibt=0;ibt<CT_MOUSE_BUTTONS;ibt++) {
				// if snooped that key is pressed
				if(_abKeysPressed[KID_MOUSE1+ibt]) {
					// mark button as pressed
					idDevice.id_aicControls[FIRST_MOUSE_BUTTON+ibt].ic_fValue = 1.0f;
				}
			}
		}

		if (_pInput->inp_bFreeMode && (pntMouse.x!=_pInput->inp_slScreenCenterX || pntMouse.y!=_pInput->inp_slScreenCenterY)) {
			SetCursorPos(_pInput->inp_slScreenCenterX, _pInput->inp_slScreenCenterY);
		}

	//0105 휠마우스 누른상태에서는 마우스가 중앙으로...
		if(_pInput->m_bTcpIp){
			if(_abKeysPressed[KID_MOUSE2]){//마우스 휠버튼 DOWN	
				if(!_pInput->m_bRButtonDown){
					//GetCursorPos(&_pInput->inp_ptOldMousePos);
					_pInput->m_bRButtonDown = TRUE;
					SetCapture(_hwndMain);
					GetCursorPos(&pntOldMouse);						// added by seo
				}
				// set cursor position to screen center
				//if (pntMouse.x!=_pInput->inp_slScreenCenterX || pntMouse.y!=_pInput->inp_slScreenCenterY) {
				//	SetCursorPos(_pInput->inp_slScreenCenterX, _pInput->inp_slScreenCenterY);
				//}
			}else if(_pInput->m_bRButtonDown){
				//SetCursorPos(_pInput->inp_ptOldMousePos.x,_pInput->inp_ptOldMousePos.y);
				_pInput->m_bRButtonDown = FALSE;
				while (ReleaseCapture() <= 0);			
			}
		}
	} else {
// end seo
		if((!_pInput->m_bTcpIp&& GetCursorPos(&pntMouse)) || (_pInput->m_bTcpIp && GetCursorPos(&pntMouse)&& _pInput->m_bWheelDown)) {
	//..
			FLOAT fDX = FLOAT( SLONG(pntMouse.x) - _pInput->inp_slScreenCenterX);
			FLOAT fDY = FLOAT( SLONG(pntMouse.y) - _pInput->inp_slScreenCenterY);

			FLOAT fSensitivity = inp_fMouseSensitivity;
			//if( inp_bAllowMouseAcceleration) 
			fSensitivity *= 0.25f;

			FLOAT fD = Sqrt(fDX*fDX+fDY*fDY);
			if (inp_bMousePrecision) {
				static FLOAT _tmTime = 0.0f;
				if( fD<inp_fMousePrecisionThreshold) _tmTime += 0.05f;
				else _tmTime = 0.0f;
				if( _tmTime>inp_fMousePrecisionTimeout) fSensitivity /= inp_fMousePrecisionFactor;
			}

			static FLOAT fDXOld;
			static FLOAT fDYOld;
			static TIME tmOldDelta;
			static CTimerValue tvBefore;
			CTimerValue tvNow = _pTimer->GetHighPrecisionTimer();
			TIME tmNowDelta = (tvNow-tvBefore).GetSeconds();
			if (tmNowDelta<0.001f) {
				tmNowDelta = 0.001f;
			}
			tvBefore = tvNow;

			FLOAT fDXSmooth = (fDXOld*tmOldDelta+fDX*tmNowDelta)/(tmOldDelta+tmNowDelta);
			FLOAT fDYSmooth = (fDYOld*tmOldDelta+fDY*tmNowDelta)/(tmOldDelta+tmNowDelta);
			fDXOld = fDX;
			fDYOld = fDY;
			tmOldDelta = tmNowDelta;
			if (inp_bFilterMouse) {
				fDX = fDXSmooth;
				fDY = fDYSmooth;
			}

			// get final mouse values
			FLOAT fMouseRelX = +fDX*fSensitivity;
			FLOAT fMouseRelY = -fDY*fSensitivity;
			if (inp_bInvertMouse) {
				fMouseRelY = -fMouseRelY;
			}
			FLOAT fMouseRelZ = _iMouseZ;
	//0105
			if(!_pInput->m_bTcpIp || (_pInput->m_bTcpIp &&_abKeysPressed[KID_MOUSE2])){//마우스 휠버튼 DOWN //1211
			idDevice.id_aicControls[0].ic_fValue =  Max(0.0f,fMouseRelX*3/4);
			idDevice.id_aicControls[1].ic_fValue = -Min(0.0f,fMouseRelX*3/4);
			idDevice.id_aicControls[2].ic_fValue =  Max(0.0f,fMouseRelY*3/4);
			idDevice.id_aicControls[3].ic_fValue = -Min(0.0f,fMouseRelY*3/4);
		}
	//..
			// if not pre-scanning
			if (!bPreScan) {
				// detect wheel up/down movement
				if(_iMouseZ>0) {
					if(_bWheelUp) {
						idDevice.id_aicControls[FIRST_MOUSE_SCROLER].ic_fValue = 0.0f;
						_bWheelUp = FALSE;
					} else {
						idDevice.id_aicControls[FIRST_MOUSE_SCROLER].ic_fValue = 1.0f;
						_bWheelUp = TRUE;
						_iMouseZ = ClampDn(_iMouseZ-120, 0);
					}
				}
				if(_iMouseZ<0) {
					if(_bWheelDn) {
						idDevice.id_aicControls[FIRST_MOUSE_SCROLER+1].ic_fValue = 0.0f;
						_bWheelDn = FALSE;
					} else {
						idDevice.id_aicControls[FIRST_MOUSE_SCROLER+1].ic_fValue = 1.0f;
						_bWheelDn = TRUE;
						_iMouseZ = ClampUp(_iMouseZ+120, 0);
					}
				}
			}
		}

		// if reading async keystate
		if(inp_iKeyboardReadingMethod==0) {
			// Get state for each mouse button
			if(GetAsyncKeyState(VK_LBUTTON)&0x8000) idDevice.id_aicControls[FIRST_MOUSE_BUTTON+0].ic_fValue = 1.0f;
			if(GetAsyncKeyState(VK_RBUTTON)&0x8000) idDevice.id_aicControls[FIRST_MOUSE_BUTTON+1].ic_fValue = 1.0f;
			if(GetAsyncKeyState(VK_MBUTTON)&0x8000) idDevice.id_aicControls[FIRST_MOUSE_BUTTON+2].ic_fValue = 1.0f;
		// if snooping messages
		} else {
			// for each mouse button
			for(INDEX ibt=0;ibt<CT_MOUSE_BUTTONS;ibt++) {
				// if snooped that key is pressed
				if(_abKeysPressed[KID_MOUSE1+ibt]) {
					// mark button as pressed
					idDevice.id_aicControls[FIRST_MOUSE_BUTTON+ibt].ic_fValue = 1.0f;
				}
			}
		}

	//0105 우측 마우스 누른상태에서는 마우스가 중앙으로...
		if(_pInput->m_bTcpIp){
			if(_abKeysPressed[KID_MOUSE2]){//마우스 우측 버튼 DOWN	
				if(!_pInput->m_bWheelDown){
					GetCursorPos(&_pInput->inp_ptOldMousePos);
					_pInput->m_bWheelDown = TRUE;
				}
				// set cursor position to screen center
				if (pntMouse.x!=_pInput->inp_slScreenCenterX || pntMouse.y!=_pInput->inp_slScreenCenterY) {
					SetCursorPos(_pInput->inp_slScreenCenterX, _pInput->inp_slScreenCenterY);
				}
			}else if(_pInput->m_bWheelDown){
				SetCursorPos(_pInput->inp_ptOldMousePos.x,_pInput->inp_ptOldMousePos.y);
				_pInput->m_bWheelDown = FALSE;
			}
		}else{
			if (pntMouse.x!=_pInput->inp_slScreenCenterX || pntMouse.y!=_pInput->inp_slScreenCenterY) {
				SetCursorPos(_pInput->inp_slScreenCenterX, _pInput->inp_slScreenCenterY);
			}
		}
	}
//..
}

static void ReadSecondMouseDevice(CInputDevice &idDevice, BOOL bPreScan)
{
	// clear contols's buffer
	idDevice.ClearControlsValue();

	// readout 2nd mouse if enabled
	if(_h2ndMouse!=NONE)
	{
		Poll2ndMouse();
		//CPrintF( "m2X: %4d, m2Y: %4d, m2B: 0x%02X\n", _i2ndMouseX, _i2ndMouseY, _i2ndMouseButtons);

		// handle 2nd mouse buttons
		if( _i2ndMouseButtons & 2) idDevice.id_aicControls[FIRST_SECOND_MOUSE_BUTTON+0].ic_fValue = 1.0f;
		if( _i2ndMouseButtons & 1) idDevice.id_aicControls[FIRST_SECOND_MOUSE_BUTTON+1].ic_fValue = 1.0f;
		if( _i2ndMouseButtons & 4) idDevice.id_aicControls[FIRST_SECOND_MOUSE_BUTTON+2].ic_fValue = 1.0f;

		// handle 2nd mouse movement
		FLOAT fDX = _i2ndMouseX;
		FLOAT fDY = _i2ndMouseY;
		FLOAT fSensitivity = inp_f2ndMouseSensitivity;

		FLOAT fD = Sqrt(fDX*fDX+fDY*fDY);
		if( inp_b2ndMousePrecision) {
			static FLOAT _tm2Time = 0.0f;
			if( fD<inp_f2ndMousePrecisionThreshold) _tm2Time += 0.05f;
			else _tm2Time = 0.0f;
			if( _tm2Time>inp_f2ndMousePrecisionTimeout) fSensitivity /= inp_f2ndMousePrecisionFactor;
		}

		static FLOAT f2DXOld;
		static FLOAT f2DYOld;
		static TIME tm2OldDelta;
		static CTimerValue tv2Before;
		CTimerValue tvNow = _pTimer->GetHighPrecisionTimer();
		TIME tmNowDelta = (tvNow-tv2Before).GetSeconds();
		if( tmNowDelta<0.001f) tmNowDelta = 0.001f;
		tv2Before = tvNow;

		FLOAT fDXSmooth = (f2DXOld*tm2OldDelta+fDX*tmNowDelta) / (tm2OldDelta+tmNowDelta);
		FLOAT fDYSmooth = (f2DYOld*tm2OldDelta+fDY*tmNowDelta) / (tm2OldDelta+tmNowDelta);
		f2DXOld = fDX;
		f2DYOld = fDY;
		tm2OldDelta = tmNowDelta;
		if( inp_bFilter2ndMouse) {
			fDX = fDXSmooth;
			fDY = fDYSmooth;
		}

		// get final mouse values
		FLOAT fMouseRelX = +fDX*fSensitivity;
		FLOAT fMouseRelY = -fDY*fSensitivity;
		if( inp_bInvert2ndMouse) fMouseRelY = -fMouseRelY;

		// just interpret values as normal
		idDevice.id_aicControls[0].ic_fValue =  Max(0.0f,fMouseRelX);
		idDevice.id_aicControls[1].ic_fValue = -Min(0.0f,fMouseRelX);
		idDevice.id_aicControls[2].ic_fValue =  Max(0.0f,fMouseRelY);
		idDevice.id_aicControls[3].ic_fValue = -Min(0.0f,fMouseRelY);
	}
}

static inline FLOAT GetRealAxisValue(InputControl &ic, SLONG slValue)
{
	// convert from min..max to -1..+1
	return FLOAT(slValue-ic.ic_slMin)/(ic.ic_slMax-ic.ic_slMin)*2.0f-1.0f;
}

static void ReadJoystickDevice(CInputDevice &idDevice, BOOL bPreScan)
{
	// clear contols's buffer
	idDevice.ClearControlsValue();

	// Get joystick index
	INDEX iJoy = idDevice.id_iDeviceIndex - FIRST_JOYSTICK_DEVICE;
	// if joystick isn't allowed
	if(iJoy>=inp_ctJoysticksAllowed) {
		// return
		return;
	}

	// if joystick polling is enabled
	if(_pInput->inp_bPollJoysticks || inp_bForceJoystickPolling) {

		// read joystick state
		JOYINFOEX ji;
		ji.dwFlags = JOY_RETURNBUTTONS|JOY_RETURNCENTERED|JOY_RETURNPOV|JOY_RETURNR|
			JOY_RETURNX|JOY_RETURNY|JOY_RETURNZ|JOY_RETURNU|JOY_RETURNV;
		ji.dwSize = sizeof( JOYINFOEX);
		MMRESULT mmResult = joyGetPosEx( JOYSTICKID1+iJoy, &ji);

		// if some error
		if( mmResult != JOYERR_NOERROR) {
			// fail
			if(inp_bAutoDisableJoysticks) {
				// kill it, so it doesn't slow down CPU
				CPrintF(TRANS("Joystick %d failed, disabling it!\n"), iJoy+1);
				idDevice.DisableDevice();
			}
			return;
		}

		// set axis values
		InputControl *pic = &idDevice.id_aicControls[0];
		pic[ 0].ic_fValue = ClampDn( GetRealAxisValue(pic[ 0],ji.dwXpos),0.0f);
		pic[ 1].ic_fValue = ClampDn(-GetRealAxisValue(pic[ 1],ji.dwXpos),0.0f);
		pic[ 2].ic_fValue = ClampDn( GetRealAxisValue(pic[ 2],ji.dwYpos),0.0f);
		pic[ 3].ic_fValue = ClampDn(-GetRealAxisValue(pic[ 3],ji.dwYpos),0.0f);
		pic[ 4].ic_fValue = ClampDn( GetRealAxisValue(pic[ 4],ji.dwZpos),0.0f);
		pic[ 5].ic_fValue = ClampDn(-GetRealAxisValue(pic[ 5],ji.dwZpos),0.0f);
		pic[ 6].ic_fValue = ClampDn( GetRealAxisValue(pic[ 6],ji.dwRpos),0.0f);
		pic[ 7].ic_fValue = ClampDn(-GetRealAxisValue(pic[ 7],ji.dwRpos),0.0f);
		pic[ 8].ic_fValue = ClampDn( GetRealAxisValue(pic[ 8],ji.dwUpos),0.0f);
		pic[ 9].ic_fValue = ClampDn(-GetRealAxisValue(pic[ 9],ji.dwUpos),0.0f);
		pic[10].ic_fValue = ClampDn( GetRealAxisValue(pic[10],ji.dwVpos),0.0f);
		pic[11].ic_fValue = ClampDn(-GetRealAxisValue(pic[11],ji.dwVpos),0.0f);

		if (!bPreScan) {
			for(INDEX ibt=0;ibt<32;ibt++) {
				InputControl &ic = idDevice.id_aicControls[FIRST_JOYSTICK_BUTTON+ibt];
				// test if the button is pressed
				if(ji.dwButtons & (1L<<ibt)) {
					ic.ic_fValue = 1.0f;
				} else {
					ic.ic_fValue = 0.0f;
				}
			}

			// if we have POV
			if (idDevice.HasJoystickPOV()) {
				// check the four pov directions
				if (ji.dwPOV==JOY_POVFORWARD) {
					idDevice.id_aicControls[FIRST_POV_CONTROL+0].ic_fValue = 1.0f;
				} else if (ji.dwPOV==JOY_POVRIGHT) {
					idDevice.id_aicControls[FIRST_POV_CONTROL+1].ic_fValue = 1.0f;
				} else if (ji.dwPOV==JOY_POVBACKWARD) {
					idDevice.id_aicControls[FIRST_POV_CONTROL+2].ic_fValue = 1.0f;
				} else if (ji.dwPOV==JOY_POVLEFT) {
					idDevice.id_aicControls[FIRST_POV_CONTROL+3].ic_fValue = 1.0f;
				// and four mid-positions
				} else if (ji.dwPOV==JOY_POVFORWARD+4500) {
					idDevice.id_aicControls[FIRST_POV_CONTROL+0].ic_fValue = 1.0f;
					idDevice.id_aicControls[FIRST_POV_CONTROL+1].ic_fValue = 1.0f;
				} else if (ji.dwPOV==JOY_POVRIGHT+4500) {
					idDevice.id_aicControls[FIRST_POV_CONTROL+1].ic_fValue = 1.0f;
					idDevice.id_aicControls[FIRST_POV_CONTROL+2].ic_fValue = 1.0f;
				} else if (ji.dwPOV==JOY_POVBACKWARD+4500) {
					idDevice.id_aicControls[FIRST_POV_CONTROL+2].ic_fValue = 1.0f;
					idDevice.id_aicControls[FIRST_POV_CONTROL+3].ic_fValue = 1.0f;
				} else if (ji.dwPOV==JOY_POVLEFT+4500) {
					idDevice.id_aicControls[FIRST_POV_CONTROL+3].ic_fValue = 1.0f;
					idDevice.id_aicControls[FIRST_POV_CONTROL+0].ic_fValue = 1.0f;
				}
			}
		}
	}
}


static void ReadDevice(CInputDevice &idDevice,BOOL bPreScan)
{
	// if device isn't enable 
	if(!idDevice.id_bDeviceEnabled) {
		// don't read it
		return;
	}

	// for each input device
	switch(idDevice.id_dtDeviceType) {
		case DT_KEYBOARD:
			ReadKeyboardDevice(idDevice,bPreScan);
		break;
		case DT_MOUSE:
			ReadMouseDevice(idDevice,bPreScan);
		break;
		case DT_SECOND_MOUSE:
			ReadSecondMouseDevice(idDevice,bPreScan);
		break;
		case DT_JOYSTICK:
			ReadJoystickDevice(idDevice,bPreScan);
		break;
		case DT_NONE:
		break;
		default:
			ASSERTALWAYS("Unknown device type");
		break;
	}
}
